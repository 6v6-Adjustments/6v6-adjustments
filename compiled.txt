settings
{
	main
	{
		Description: "Overwatch 1 Emulator v0.8.5 (staging build)\r\n\r\necksdee#11729's attempt to accurately recreate \r\nthe last version of Overwatch 1 using workshop.\r\n\r\nMain build: KHTG0\r\nStaging build: ESMXJ\r\n\r\nContributors:\r\necksdee#11729\r\nSnappy#11809\r\nKingDonMike#2694\r\nthenova#21104\r\npretz#11551\r\n\r\nGamemode:\r\nworkshop.codes/ow1-emulator\r\n\r\nDiscord:\r\ndsc.gg/ow1\r\ndiscord.gg/GMVqwYXbWB\r\n\r\nSource code:\r\ngithub.com/MaxwellJung/ow1_emulator"
		Mode Name: "Overwatch 1 Emulator"
	}
	lobby
	{
		Map Rotation: After A Game
		Match Voice Chat: Enabled
		Max Spectators: 12
		Max Team 1 Players: 6
		Max Team 2 Players: 6
		Return To Lobby: Never
		Team Balancing: After A Game
	}
	modes
	{
		Assault
		{
			enabled maps
			{
				Hanamura
				Horizon Lunar Colony
				Paris
				Temple of Anubis
				Volskaya Industries
			}
		}
		Control
		{
			enabled maps
			{
				Busan 972777519512068154
				Ilios 972777519512068154
				Lijiang Tower 972777519512068153
				Nepal 972777519512068154
				Oasis 972777519512068292
			}
		}
		Escort
		{
			enabled maps
			{
				Dorado 972777519512068153
				Havana 972777519512068154
				Rialto
				Route 66 972777519512068154
				Watchpoint: Gibraltar 972777519512068292
			}
		}
		Hybrid
		{
			enabled maps
			{
				Blizzard World 972777519512068154
				Eichenwalde 972777519512068154
				Hollywood 972777519512068154
				King's Row 972777519512068153
				Numbani
			}
		}
		Practice Range
		{
			enabled maps
			{
			}
		}
		General
		{
			Hero Limit: 1 Per Team
			Limit Roles: Off
			Tank Role Passive Health Bonus: Always Enabled
			Competitive Rules: On
		}
	}
	heroes
	{
		General
		{
			Ana
			{
				Ultimate Generation Nano Boost: 100%
			}
			Ashe
			{
				Ultimate Generation B.O.B.: 100%
			}
			Baptiste
			{
				Ultimate Generation Amplification Matrix: 100%
			}
			Bastion
			{
				Ultimate Generation Configuration: Artillery: 100%
			}
			Brigitte
			{
				Health: 100%
				Ultimate Generation Rally: 96.53571428571429%
			}
			Cassidy
			{
				Ultimate Generation Deadeye: 110.11904761904762%
			}
			Doomfist
			{
				Ammunition Regeneration Time Scalar: 162%
			}
			D.Va
			{
				Defense Matrix Maximum Time: 67%
				Ultimate Generation Self-Destruct: 100%
			}
			Echo
			{
				Ultimate Generation Duplicate: 75.02218278615794%
			}
			Genji
			{
				Ultimate Generation Dragonblade: 100%
			}
			Hanzo
			{
				Ultimate Generation Dragonstrike: 100%
			}
			Junkrat
			{
				Ultimate Generation RIP-Tire: 100%
			}
			Lúcio
			{
				Ultimate Generation Sound Barrier: 82.31292517006803%
			}
			Mei
			{
				Ultimate Generation Blizzard: 108.69565217391305%
			}
			Mercy
			{
				Ultimate Generation Valkyrie: 100%
				Sympathetic Recovery: Off
			}
			Moira
			{
				Ultimate Generation Coalescence: 95%
			}
			Pharah
			{
				Ultimate Generation Barrage: 95.23809523809524%
			}
			Ramattra
			{
				Health: 100%
			}
			Reaper
			{
				Ultimate Generation Death Blossom: 91.9047619047619%
			}
			Reinhardt
			{
				Barrier Field Recharge Rate: 139%
				Health: 114.28571428571429%
				Ultimate Generation Earthshatter: 107.14285714285714%
			}
			Roadhog
			{
				Ultimate Generation Whole Hog: 108.03571428571429%
			}
			Sigma
			{
				Experimental Barrier Recharge Rate: 80%
				Health: 100%
				Ultimate Generation Gravitic Flux: 107.14285714285714%
			}
			Soldier: 76
			{
				Ultimate Generation Tactical Visor: 110%
			}
			Sombra
			{
				Ultimate Generation EMP: 115%
			}
			Symmetra
			{
				Ultimate Generation Photon Barrier: 100%
			}
			Torbjörn
			{
				Health: 111.11111111111111%
				Ultimate Generation Molten Core: 100%
			}
			Tracer
			{
				Ultimate Generation Pulse Bomb: 100%
			}
			Widowmaker
			{
				Ultimate Generation Infra-Sight: 100%
			}
			Winston
			{
				Health: 107.6923076923077%
				Ultimate Generation Primal Rage: 120.12987012987013%
			}
			Wrecking Ball
			{
				Ultimate Generation Minefield: 108.76623376623377%
				Piledriver Cooldown Time: 125%
			}
			Zarya
			{
				Health: 100%
			}
			Zenyatta
			{
				Ultimate Generation Transcendence: 100%
			}
		}
	}
}
variables {
    global:
        0: i
        1: ow1_tank_heroes
        2: ow1_damage_heroes
        3: ow1_support_heroes
        4: ow2_tank_heroes
        5: ow2_damage_heroes
        6: ow2_support_heroes
        7: tank_heroes
        8: damage_heroes
        9: support_heroes
        10: all_heroes
        11: hero_select_time
        12: max_tank_count
        13: max_damage_count
        14: max_support_count
        15: allow_ow1_heroes
        16: allow_ow2_heroes
        17: ready_hud
        18: ready_description_hud
        19: ult_cost
        20: health_pool
        21: PHI
        22: debug
    player:
        0: last_hero_played
        1: hero_switched
        2: hero_id
        3: call_reset
        4: call_init
        5: text_huds
        6: progress_bar_huds
        7: entity_huds
        8: player_health
        9: friendly_doomfist_player
        10: friendly_orisa_player
        11: friendly_sombra_player
        12: enemy_doomfist_player
        13: enemy_orisa_player
        14: enemy_sombra_player
        15: role
        16: allowed_heroes
        17: ready
        18: lsi_o
        19: lsi_c
        20: lsi_r
        21: lsi_u
        22: lsi_d
        23: lsi_nabla
        24: lsi_i
        25: lsi_x
        26: hp_health
        27: hp_armor
        28: hp_shields
        29: stored_spawn_pos
        30: missing_ult_points
        31: ult_percent_compensated
        32: ult_charge_compensated
        33: self_healing_percent
        34: self_healing_modification
        35: support_passive_active
        36: last_time_damage_taken
        37: ult_point_while_ult_active
        38: start_time_ult
        39: current_configuration
        40: self_repair_time_left
        41: self_repair_instance
        42: self_repair_gui
        43: machine_gun_ammo
        44: machine_gun_ready
        45: machine_gun_reload_timer
        46: machine_gun_gui
        47: inspire_duration
        48: is_using_uppercut
        49: is_using_slam
        50: e_pressed_by_bot
        51: pressing_uppercut_key
        52: is_hit_by_uppercut
        53: shift_pressed_by_bot
        54: pressing_slam_key
        55: slam_to_use
        56: current_position
        57: proto_indicator_slam_position
        58: indicator_slam_position
        59: indicator_slam_direction
        60: slam_damage
        61: slam_damage_text_entity
        62: slammed_victims
        63: indicator_entity
        64: punched_victims
        65: wall_impacted_victims
        66: punch_charge_time
        67: hero_id_duplicated
        68: flashbang_origin_position
        69: flashbang_exploded
        70: freeze_progress
        71: is_frozen
        72: freeze_slow_linger_time
        73: freeze_move_penalty
        74: is_using_guardian_angel
        75: is_slingshotting
        76: slingshot_velocity
        77: is_using_supercharger
        78: is_supercharged
        79: orisa_supercharger_entity
        80: orisa_supercharger_uptime
        81: orisa_supercharger_position
        82: orisa_beam_entity
        83: orisa_beam_sound_effect
        84: is_using_halt
        85: is_snared
        86: halt_position
        87: halt_ending_position
        88: halt_entity1
        89: halt_entity2
        90: halt_pull_line_entity
        91: position
        92: barrier_projectile
        93: barrier_proj_v0
        94: barrier_proj_p0
        95: barrier_proj_t
        96: barrier_proj_velocity
        97: barrier_proj_position
        98: barrier_position
        99: barrier_orientation
        100: barrier_sample_x
        101: barrier_sample_y
        102: barrier_sample_z
        103: barrier_sample_radius
        104: barrier_sample_theta
        105: barrier_sample_point
        106: barrier_entity_positions
        107: barrier_entities
        108: barrier_uptime
        109: barrier_active
        110: barrier_health
        111: orisa_barrier_hit_positions
        112: barrier_health_hud
        113: orisa_ammo
        114: orisa_ammo_hud
        115: is_orisa_reloading
        116: time_hook_was_active
        117: hack_damage_modifier
        118: scoped_shot_distance
        119: scoped_damage_base
        120: ow2_scoped_damage_falloff_scalar
        121: ow1_scoped_damage_falloff_scalar
        122: expected_scoped_damage
        123: self_bubble_cooldown
        124: ally_bubble_cooldown
        125: self_bubble_cd_text
        126: ally_bubble_cd_text
}
subroutines {
    0: resetHero
    1: initHero
    2: respawnSameState
    3: lockTank
    4: lockDamage
    5: lockSupport
    6: unlockTank
    7: unlockDamage
    8: unlockSupport
    9: findLineSphereIntersection
    10: clearCustomHealth
    11: applyCustomHealth
    12: removeSelfHealing
    13: startTank
    14: endTank
    15: startSelfRepair
    16: stopSelfRepair
    17: createSelfRepairGUI
    18: destroySelfRepairGUI
    19: startMachineGunReload
    20: createMachineGunGUI
    21: destroyMachineGunGUI
    22: executeUppercut
    23: detectUpercutHit
    24: executeSlam
    25: startSlamAnimation
    26: initiateGroundSlam
    27: initiateIndicatorSlam
    28: createSlamDamageGui
    29: destroySlamDamageGui
    30: createSlamIndicatorGui
    31: destroySlamIndicatorGui
    32: initMei
    33: clearFreezeEffect
    34: startSupercharger
    35: endSupercharger
    36: shootHalt
    37: explodeHalt
    38: throwBarrier
    39: deployBarrier
    40: destroyBarrier
    41: fibonacciSphere
    42: createBarrierHud
    43: destroyBarrierHud
    44: resetFusionDriver
    45: reloadFusionDriver
    46: refreshAmmo
    47: createOrisaAmmoHud
    48: destroyOrisaAmmoHud
    49: initRoadhog
    50: showSelfBubbleCD
    51: hideSelfBubbleCD
    52: showAllyBubbleCD
    53: hideAllyBubbleCD
}
rule ("Initialize global variables") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(max_tank_count, Workshop Setting Integer(Custom String("Role limit", Null, Null, Null), Custom String("Tank", Null, Null, Null), 2, 0, 6, 0));
        Set Global Variable(max_damage_count, Workshop Setting Integer(Custom String("Role limit", Null, Null, Null), Custom String("Damage", Null, Null, Null), 2, 0, 6, 1));
        Set Global Variable(max_support_count, Workshop Setting Integer(Custom String("Role limit", Null, Null, Null), Custom String("Support", Null, Null, Null), 2, 0, 6, 2));
        Set Global Variable(allow_ow1_heroes, Workshop Setting Toggle(Custom String("Heroes", Null, Null, Null), Custom String("Overwatch 1", Null, Null, Null), True, 0));
        Set Global Variable(allow_ow2_heroes, Workshop Setting Toggle(Custom String("Heroes", Null, Null, Null), Custom String("Overwatch 2", Null, Null, Null), False, 0));
        Set Global Variable(PHI, 3.883222077450933);
        Set Global Variable(debug, Workshop Setting Toggle(Custom String("Dev Tools", Null, Null, Null), Custom String("debug mode", Null, Null, Null), False, 0));
    }
}

rule ("[hero_switch.opy]: detect hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).last_hero_played != Hero Of(Event Player);
    }
    actions {
        Set Player Variable(Event Player, hero_switched, True);
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, last_hero_played, Hero Of(Event Player));
        Set Player Variable(Event Player, hero_id, Index Of Array Value(All Heroes, (Event Player).last_hero_played));
        Set Player Variable(Event Player, hero_switched, False);
    }
}

rule ("[reset.opy]: resetHero()") {
    event {
        Subroutine;
        resetHero;
    }
    actions {
        Set Player Variable(Event Player, call_reset, True);
        "Call other reset functions"
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, call_reset, False);
    }
}

rule ("[reset.opy]: initHero()") {
    event {
        Subroutine;
        initHero;
    }
    actions {
        Set Player Variable(Event Player, call_init, True);
        "Call other init functions"
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, call_init, False);
    }
}

rule ("[reset.opy]: Reset abilities") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_reset == True;
    }
    actions {
        Allow Button(Event Player, Button(Primary Fire));
        Allow Button(Event Player, Button(Secondary Fire));
        Allow Button(Event Player, Button(Ability 1));
        Allow Button(Event Player, Button(Ability 2));
        Allow Button(Event Player, Button(Ultimate));
        Allow Button(Event Player, Button(Melee));
        Allow Button(Event Player, Button(Jump));
        Allow Button(Event Player, Button(Crouch));
        Allow Button(Event Player, Button(Reload));
        Allow Button(Event Player, Button(Interact));
        Set Primary Fire Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, True);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability 2 Enabled(Event Player, True);
        Set Ultimate Ability Enabled(Event Player, True);
        Set Melee Enabled(Event Player, True);
        Set Jump Enabled(Event Player, True);
        Set Crouch Enabled(Event Player, True);
        Set Reload Enabled(Event Player, True);
    }
}

rule ("[reset.opy]: Reset stats") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_reset == True;
    }
    actions {
        Set Damage Dealt(Event Player, 100);
        Set Damage Received(Event Player, 100);
        Set Projectile Speed(Event Player, 100);
        Set Projectile Gravity(Event Player, 100);
        Set Healing Dealt(Event Player, 100);
        Set Healing Received(Event Player, 100);
        Set Knockback Received(Event Player, 100);
        Set Knockback Dealt(Event Player, 100);
    }
}

rule ("[reset.opy]: Reset statuses") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_reset == True;
    }
    actions {
        Clear Status(Event Player, Asleep);
        Clear Status(Event Player, Burning);
        Clear Status(Event Player, Frozen);
        Clear Status(Event Player, Hacked);
        Clear Status(Event Player, Invincible);
        Clear Status(Event Player, Knocked Down);
        Clear Status(Event Player, Phased Out);
        Clear Status(Event Player, Rooted);
        Clear Status(Event Player, Stunned);
        Clear Status(Event Player, Unkillable);
    }
}

rule ("[reset.opy]: Reset friendly/enemy players") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_reset == True;
    }
    actions {
        Set Player Variable(Event Player, friendly_doomfist_player, First Of(Players On Hero(Hero(Doomfist), Team Of(Event Player))));
        Set Player Variable(Event Player, enemy_doomfist_player, First Of(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player)))));
        Set Player Variable(Event Player, friendly_orisa_player, First Of(Players On Hero(Hero(Orisa), Team Of(Event Player))));
        Set Player Variable(Event Player, enemy_orisa_player, First Of(Players On Hero(Hero(Orisa), Opposite Team Of(Team Of(Event Player)))));
        Set Player Variable(Event Player, friendly_sombra_player, First Of(Players On Hero(Hero(Sombra), Team Of(Event Player))));
        Set Player Variable(Event Player, enemy_sombra_player, First Of(Players On Hero(Hero(Sombra), Opposite Team Of(Team Of(Event Player)))));
    }
}

rule ("[reset.opy]: Reset HUDs and GUI") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_reset == True;
    }
    actions {
        "Clear GUI"
        For Global Variable(i, 0, Count Of((Event Player).text_huds), 1);
            Destroy HUD Text(Value In Array((Event Player).text_huds, Global.i));
        End;
        For Global Variable(i, 0, Count Of((Event Player).progress_bar_huds), 1);
            Destroy Progress Bar HUD Text(Value In Array((Event Player).progress_bar_huds, Global.i));
        End;
        For Global Variable(i, 0, Count Of((Event Player).entity_huds), 1);
            Destroy Effect(Value In Array((Event Player).entity_huds, Global.i));
        End;
        Set Player Variable(Event Player, text_huds, Empty Array);
        Set Player Variable(Event Player, progress_bar_huds, Empty Array);
        Set Player Variable(Event Player, entity_huds, Empty Array);
    }
}

rule ("[reset.opy]: Reinitialize hero on new round") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Between Rounds == True;
    }
    actions {
        Wait Until(Not(Is Between Rounds), 999999999999999);
        Call Subroutine(resetHero);
        Call Subroutine(initHero);
    }
}

rule ("[reset.opy]: Reinitialize hero on hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_switched == True;
    }
    actions {
        Wait Until(Not((Event Player).hero_switched), 999999999999999);
        Call Subroutine(resetHero);
        Call Subroutine(initHero);
    }
}

rule ("[reset.opy]: respawnSameState()") {
    event {
        Subroutine;
        respawnSameState;
    }
    actions {
        Set Player Variable(Event Player, player_health, Health(Event Player));
        Kill(Event Player, Null);
        "Use resurrect to keep the same position and angle"
        Resurrect(Event Player);
        "Wait to set health else the player will be full life"
        Wait(0.016, Ignore Condition);
        Set Player Health(Event Player, (Event Player).player_health);
    }
}

rule ("[role_lock.opy]: Find player's role") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_switched == True;
    }
    actions {
        Wait Until(Not((Event Player).hero_switched), 999999999999999);
        If(Array Contains(Global.tank_heroes, Hero Of(Event Player)));
            Set Player Variable(Event Player, role, 1);
        Else If(Array Contains(Global.damage_heroes, Hero Of(Event Player)));
            Set Player Variable(Event Player, role, 2);
        Else If(Array Contains(Global.support_heroes, Hero Of(Event Player)));
            Set Player Variable(Event Player, role, 3);
        Else;
            Set Player Variable(Event Player, role, 0);
    }
}

rule ("[role_lock.opy]: Define tank, damage, support heroes array") {
    event {
        Ongoing - Global;
    }
    actions {
        "Tanks"
        Set Global Variable(ow1_tank_heroes, All Tank Heroes);
        Modify Global Variable(ow1_tank_heroes, Remove From Array By Value, Hero(Doomfist));
        Set Global Variable(ow2_tank_heroes, Array(Hero(Junker Queen), Hero(Ramattra)));
        Modify Global Variable(ow1_tank_heroes, Remove From Array By Value, Global.ow2_tank_heroes);
        "Damage"
        Set Global Variable(ow1_damage_heroes, All Damage Heroes);
        Modify Global Variable(ow1_damage_heroes, Append To Array, Hero(Doomfist));
        Set Global Variable(ow2_damage_heroes, Array(Hero(Sojourn)));
        Modify Global Variable(ow1_damage_heroes, Remove From Array By Value, Global.ow2_damage_heroes);
        "Supports"
        Set Global Variable(ow1_support_heroes, All Support Heroes);
        Set Global Variable(ow2_support_heroes, Array(Hero(Kiriko), Hero(Lifeweaver), Hero(Illari)));
        Modify Global Variable(ow1_support_heroes, Remove From Array By Value, Global.ow2_support_heroes);
        Set Global Variable(tank_heroes, Empty Array);
        Set Global Variable(damage_heroes, Empty Array);
        Set Global Variable(support_heroes, Empty Array);
        If(Compare(Global.allow_ow1_heroes, ==, True));
            Modify Global Variable(tank_heroes, Append To Array, Global.ow1_tank_heroes);
            Modify Global Variable(damage_heroes, Append To Array, Global.ow1_damage_heroes);
            Modify Global Variable(support_heroes, Append To Array, Global.ow1_support_heroes);
        End;
        If(Compare(Global.allow_ow2_heroes, ==, True));
            Modify Global Variable(tank_heroes, Append To Array, Global.ow2_tank_heroes);
            Modify Global Variable(damage_heroes, Append To Array, Global.ow2_damage_heroes);
            Modify Global Variable(support_heroes, Append To Array, Global.ow2_support_heroes);
        End;
        Set Global Variable(all_heroes, Empty Array);
        Modify Global Variable(all_heroes, Append To Array, Global.tank_heroes);
        Modify Global Variable(all_heroes, Append To Array, Global.damage_heroes);
        Modify Global Variable(all_heroes, Append To Array, Global.support_heroes);
    }
}

rule ("[role_lock.opy]: Override allowed heroes list when player joins lobby") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    actions {
        Set Player Allowed Heroes(Event Player, Global.all_heroes);
    }
}

rule ("[role_lock.opy]: Skip hero assembly") {
    event {
        Ongoing - Global;
    }
    conditions {
        Is Assembling Heroes == True;
    }
    actions {
        "Reset every player's role"
        Set Player Variable(All Players(All Teams), role, 0);
        "Save assemble hero time"
        Set Global Variable(hero_select_time, Match Time);
        "Go to the end of the assembling heroes"
        Set Match Time(0);
        Wait Until(Not(Is Assembling Heroes), 999999999999999);
        "Give back assemble hero time"
        Set Match Time(Add(Match Time, Global.hero_select_time));
    }
}

rule ("[role_lock.opy]: Lock tanks above role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 1)))) >= Global.max_tank_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(lockTank);
    }
}

rule ("[role_lock.opy]: Lock damage above role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 2)))) >= Global.max_damage_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(lockDamage);
    }
}

rule ("[role_lock.opy]: Lock supports above role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 3)))) >= Global.max_support_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(lockSupport);
    }
}

rule ("[role_lock.opy]: Unlock tanks below role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 1)))) < Global.max_tank_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(unlockTank);
    }
}

rule ("[role_lock.opy]: Unlock damage below role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 2)))) < Global.max_damage_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(unlockDamage);
    }
}

rule ("[role_lock.opy]: Unlock supports below role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 3)))) < Global.max_support_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(unlockSupport);
    }
}

rule ("[role_lock.opy]: lockTank()") {
    event {
        Subroutine;
        lockTank;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        Modify Player Variable(Event Player, allowed_heroes, Remove From Array By Value, Global.tank_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: lockDamage()") {
    event {
        Subroutine;
        lockDamage;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        Modify Player Variable(Event Player, allowed_heroes, Remove From Array By Value, Global.damage_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: lockSupport()") {
    event {
        Subroutine;
        lockSupport;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        Modify Player Variable(Event Player, allowed_heroes, Remove From Array By Value, Global.support_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: unlockTank()") {
    event {
        Subroutine;
        unlockTank;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        Modify Player Variable(Event Player, allowed_heroes, Append To Array, Global.tank_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: unlockDamage()") {
    event {
        Subroutine;
        unlockDamage;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        Modify Player Variable(Event Player, allowed_heroes, Append To Array, Global.damage_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: unlockSupport()") {
    event {
        Subroutine;
        unlockSupport;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        Modify Player Variable(Event Player, allowed_heroes, Append To Array, Global.support_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[ready.opy]: Create ready HUD") {
    event {
        Ongoing - Global;
    }
    conditions {
        Is In Setup == True;
    }
    actions {
        Create HUD Text(All Players(All Teams), Custom String("{0}/{1} ready", Count Of(Filtered Array(All Players(All Teams), Compare((Current Array Element).ready, ==, True))), Number Of Players(All Teams), Null), Null, Null, Top, 9999, If-Then-Else(Is True For All(All Players(All Teams), (Current Array Element).ready), Color(Green), Color(Red)), Null, Null, String and Color, Default Visibility);
        Set Global Variable(ready_hud, Last Text ID);
        Create HUD Text(All Players(All Teams), Null, Custom String("Press {0} + {1} to ready", Input Binding String(Button(Interact)), Input Binding String(Button(Reload)), Null), Null, Top, 9999, Null, Color(White), Null, String and Color, Default Visibility);
        Set Global Variable(ready_description_hud, Last Text ID);
        Wait Until(Not(Is In Setup), 999999999999999);
        Destroy HUD Text(Global.ready_hud);
        Destroy HUD Text(Global.ready_description_hud);
    }
}

rule ("[ready.opy]: Unready all players when entering setup") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is In Setup == True;
    }
    actions {
        Set Player Variable(Event Player, ready, False);
    }
}

rule ("[ready.opy]: Toggle ready when pressing Interact + Reload") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is In Setup == True;
        Is Button Held(Event Player, Button(Interact)) == True;
        Is Button Held(Event Player, Button(Reload)) == True;
    }
    actions {
        Set Player Variable(Event Player, ready, Not((Event Player).ready));
    }
}

rule ("[ready.opy]: Start match when everyone ready") {
    event {
        Ongoing - Global;
    }
    conditions {
        "Guard to prevent incorrect match time modification"
        Is Game In Progress == False;
        "Guard to prevent incorrect match time modification"
        Is Assembling Heroes == False;
        Is In Setup == True;
        Match Time > 5;
        Is True For All(All Players(All Teams), (Current Array Element).ready) == True;
    }
    actions {
        Set Match Time(5);
    }
}

rule ("[hit_detection.opy]: findLineSphereIntersection()") {
    event {
        Subroutine;
        findLineSphereIntersection;
    }
    actions {
        Set Player Variable(Event Player, lsi_nabla, Subtract(Raise To Power(Absolute Value(Dot Product((Event Player).lsi_u, Subtract((Event Player).lsi_o, (Event Player).lsi_c))), 2), Subtract(Raise To Power(Distance Between((Event Player).lsi_o, (Event Player).lsi_c), 2), Raise To Power((Event Player).lsi_r, 2))));
        "line goes through sphere"
        If(Compare((Event Player).lsi_nabla, >, 0));
            Set Player Variable(Event Player, lsi_d, Array(Subtract(Multiply(-1, Dot Product((Event Player).lsi_u, Subtract((Event Player).lsi_o, (Event Player).lsi_c))), Square Root((Event Player).lsi_nabla)), Add(Multiply(-1, Dot Product((Event Player).lsi_u, Subtract((Event Player).lsi_o, (Event Player).lsi_c))), Square Root((Event Player).lsi_nabla))));
        "line tangent to sphere"
        Else If(Compare((Event Player).lsi_nabla, ==, 0));
            Set Player Variable(Event Player, lsi_d, Array(Multiply(-1, Dot Product((Event Player).lsi_u, Subtract((Event Player).lsi_o, (Event Player).lsi_c)))));
        "no intersection/solution"
        Else If(Compare((Event Player).lsi_nabla, <, 0));
            Set Player Variable(Event Player, lsi_d, Empty Array);
        Else;
            Set Player Variable(Event Player, lsi_d, Empty Array);
        End;
        Set Player Variable(Event Player, lsi_x, Empty Array);
        For Player Variable(Event Player, lsi_i, 0, Count Of((Event Player).lsi_d), 1);
            If(Compare(Value In Array((Event Player).lsi_d, (Event Player).lsi_i), >=, 0));
                Modify Player Variable(Event Player, lsi_x, Append To Array, Add((Event Player).lsi_o, Multiply(Value In Array((Event Player).lsi_d, (Event Player).lsi_i), (Event Player).lsi_u)));
            End;
        End;
    }
}

rule ("[custom_health_handler.opy]: Reset hp") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_reset == True;
    }
    actions {
        Call Subroutine(clearCustomHealth);
    }
}

rule ("[custom_health_handler.opy]: clearCustomHealth()") {
    event {
        Subroutine;
        clearCustomHealth;
    }
    actions {
        Remove All Health Pools From Player(Event Player);
        Wait(0.016, Ignore Condition);
        Set Max Health(Event Player, 100.001);
        Wait(0.016, Ignore Condition);
        Set Max Health(Event Player, 100);
        Heal(Event Player, Null, 999999999999999);
    }
}

rule ("[custom_health_handler.opy]: applyCustomHealth()") {
    event {
        Subroutine;
        applyCustomHealth;
    }
    actions {
        "If the player is in spawn, teleport them out as they are invulnerable in spawn"
        If(Is In Spawn Room(Event Player));
            Start Camera(Event Player, Eye Position(Event Player), Add(Eye Position(Event Player), Facing Direction Of(Event Player)), 0.001);
            Set Player Variable(Event Player, stored_spawn_pos, Position Of(Event Player));
            Wait(0.016, Ignore Condition);
            Teleport(Event Player, Add(Position Of(Event Player), Multiply(100, Up)));
            Wait Until(Not(Or(Or(Is In Spawn Room(Event Player), Has Status(Event Player, Invincible)), Has Status(Event Player, Unkillable))), 1);
            Wait(0.016, Ignore Condition);
        End;
        "If the player is duplicating a hero, wait until Echo is no longer invulnerable"
        If(Is Duplicating(Event Player));
            Wait Until(Not(Or(Has Status(Event Player, Invincible), Has Status(Event Player, Unkillable))), 1);
            Wait(0.016, Ignore Condition);
        End;
        "# Applying Custom Health ##\n Apply an unkillable status so we don't accidentally kill the player"
        Set Status(Event Player, Event Player, Unkillable, 999999999999999);
        "Damage the player so they're at one health"
        Damage(Event Player, Null, 999999999999999);
        Wait Until(Compare(Health(Event Player), <=, 1), 1);
        "Apply temporary base health to the player"
        Add Health Pool To Player(Event Player, Health, 999999999999999, True, True);
        Add Health Pool To Player(Event Player, Armor, 999999999999999, True, True);
        Add Health Pool To Player(Event Player, Shields, 999999999999999, True, True);
        "Remove temporary base health from the player"
        Remove All Health Pools From Player(Event Player);
        Wait Until(Compare(Max Health(Event Player), <=, 1), 1);
        "Apply custom health pool to player"
        If(Compare((Event Player).hp_health, >, 0));
            Add Health Pool To Player(Event Player, Health, Max(1, Subtract((Event Player).hp_health, 1)), True, True);
        End;
        If(Compare((Event Player).hp_armor, >, 0));
            Add Health Pool To Player(Event Player, Armor, Max(1, (Event Player).hp_armor), True, True);
        End;
        If(Compare((Event Player).hp_shields, >, 0));
            Add Health Pool To Player(Event Player, Shields, Max(1, (Event Player).hp_shields), True, True);
        End;
        Heal(Event Player, Null, 999999999999999);
        Clear Status(Event Player, Unkillable);
        "Teleport player back if they were in spawn."
        If(Compare((Event Player).stored_spawn_pos, !=, Null));
            Teleport(Event Player, (Event Player).stored_spawn_pos);
            Set Player Variable(Event Player, stored_spawn_pos, Null);
        End;
        Stop Camera(Event Player);
        "Wait 1 second for everything to settle"
        Wait(1, Ignore Condition);
        If(Compare(Max Health(Event Player), !=, Add(Add((Event Player).hp_health, (Event Player).hp_armor), (Event Player).hp_shields)));
            Call Subroutine(clearCustomHealth);
            Loop;
        End;
    }
}

rule ("[ult_charge.opy]: initialize overwatch 1 ultimate costs") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(D.Va)), 1540);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Reinhardt)), 1542.056074766355);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Roadhog)), 2240.7407407407404);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Sigma)), 1962.6168224299065);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Winston)), 1541.6666666666667);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Wrecking Ball)), 1536.6972477064219);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Zarya)), 2101.8518518518517);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Ashe)), 2240);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Bastion)), 2310);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Cassidy)), 1681.8181818181818);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Echo)), 2254.6666666666665);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Genji)), 1932);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Hanzo)), 1680);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Junkrat)), 1925);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Mei)), 1605.5045871559632);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Pharah)), 2105.2631578947367);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Reaper)), 2097.8260869565215);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Soldier: 76)), 2310);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Sombra)), 1400.0000000000002);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Symmetra)), 1680);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Torbjörn)), 2142);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Tracer)), 1260);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Widowmaker)), 1540);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Ana)), 2100);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Baptiste)), 2310);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Brigitte)), 2786.5979381443303);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Lúcio)), 2951.2195121951218);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Mercy)), 1820);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Moira)), 2800);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Zenyatta)), 2310);
    }
}

rule ("[ult_charge.opy]: Reset ult charge") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_reset == True;
    }
    actions {
        Set Player Variable(Event Player, missing_ult_points, 0);
        Set Player Variable(Event Player, ult_percent_compensated, 0);
        Set Ultimate Charge(Event Player, 0);
    }
}

rule ("[ult_charge.opy]: Reset ult charge for DVa (special case)") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        (Event Player).call_reset == True;
    }
    actions {
        Wait Until(Compare(Ultimate Charge Percent(Event Player), >, 0), 1);
        Set Ultimate Charge(Event Player, 0);
    }
}

rule ("[ult_charge.opy]: Remember missing ult charge from damaging tank") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Victim != Event Player;
        Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
        "Roadhog passive"
        Array Contains(Array(Hero(Roadhog)), Hero Of(Victim)) == False;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Modify Player Variable(Event Player, missing_ult_points, Add, Multiply(0.3, Event Damage));
    }
}

rule ("[ult_charge.opy]: Remember missing ult charge from healing tank") {
    event {
        Player Dealt Healing;
        All;
        All;
    }
    conditions {
        Array Contains(All Tank Heroes, Hero Of(Healee)) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Modify Player Variable(Event Player, missing_ult_points, Add, Multiply(0.3, Event Healing));
    }
}

rule ("[ult_charge.opy]: Compensate missing ultimate percentage") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).missing_ult_points > 0;
    }
    actions {
        "add 3% extra to compensate for rounding error"
        Set Player Variable(Event Player, ult_percent_compensated, Add(Divide(Multiply(100, (Event Player).missing_ult_points), Value In Array(Global.ult_cost, (Event Player).hero_id)), 3));
        Set Ultimate Charge(Event Player, Add(Ultimate Charge Percent(Event Player), (Event Player).ult_percent_compensated));
        Set Player Variable(Event Player, ult_charge_compensated, Multiply(Divide((Event Player).ult_percent_compensated, 100), Value In Array(Global.ult_cost, (Event Player).hero_id)));
        Modify Player Variable(Event Player, missing_ult_points, Subtract, (Event Player).ult_charge_compensated);
    }
}

rule ("[ult_charge.opy]: Reset ult compensation after using ult") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, missing_ult_points, 0);
        Set Player Variable(Event Player, ult_percent_compensated, 0);
    }
}

rule ("[passives/tank/knockback.opy]: Correct knockback resistance") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_init == True;
        Array Contains(All Tank Heroes, Hero Of(Event Player)) == True;
        "Exception for Reinhardt (Steadfast passive)"
        Array Contains(Array(Hero(Reinhardt)), Hero Of(Event Player)) == False;
    }
    actions {
        Set Knockback Received(Event Player, 142.85714285714286);
    }
}

rule ("[passives/support/self_heal.opy]: Remove support self healing passive") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_init == True;
        Array Contains(All Support Heroes, Hero Of(Event Player)) == True;
        "Exception to support healing passive"
        Array Contains(Array(Hero(Mercy)), Hero Of(Event Player)) == False;
    }
    actions {
        Call Subroutine(removeSelfHealing);
    }
}

rule ("[passives/support/self_heal.opy]: Reset self healing") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_reset == True;
    }
    actions {
        Stop Healing Modification((Event Player).self_healing_modification);
        Set Player Variable(Event Player, support_passive_active, True);
    }
}

rule ("[passives/support/self_heal.opy]: removeSelfHealing()") {
    event {
        Subroutine;
        removeSelfHealing;
    }
    actions {
        Stop Healing Modification((Event Player).self_healing_modification);
        Set Player Variable(Event Player, self_healing_percent, 0);
        Start Healing Modification(Event Player, Event Player, (Event Player).self_healing_percent, Receivers Healers and Healing Percent);
        Set Player Variable(Event Player, self_healing_modification, Last Healing Modification ID);
    }
}

rule ("[passives/support/self_heal.opy]: Get time when support hero take damage") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Array Contains(Global.support_heroes, Hero Of(Event Player)) == True;
    }
    actions {
        Set Player Variable(Event Player, last_time_damage_taken, Total Time Elapsed);
        Set Player Variable(Event Player, support_passive_active, False);
    }
}

rule ("[passives/support/self_heal.opy]: Check if support passive is active") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).support_passive_active == False;
        Array Contains(Global.support_heroes, Hero Of(Event Player)) == True;
        Subtract(Total Time Elapsed, (Event Player).last_time_damage_taken) > 1.5;
    }
    actions {
        Set Player Variable(Event Player, support_passive_active, True);
    }
}

rule ("[ana/ammo.opy]: Initialize Ana clip size") {
    event {
        Ongoing - Each Player;
        All;
        Ana;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Set Ammo(Event Player, 0, 12);
        Set Max Ammo(Event Player, 0, 12);
    }
}

rule ("[ana/sleep.opy]: Set default sleep dart cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Ana;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 12);
    }
}

rule ("[ana/sleep.opy]: Sleep tanks for longer duration") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Array Contains(All Tank Heroes, Hero Of(Event Player)) == True;
        Has Status(Event Player, Asleep) == True;
    }
    actions {
        "5/3.5 is the ratio of regular sleep time to tank sleep time"
        Set Status(Event Player, Null, Asleep, 7.692307692307692);
    }
}

rule ("[ana/nade.opy]: Heal OW1 healing with biotic grenade") {
    event {
        Player Dealt Healing;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Heal(Healee, Healer, Subtract(Multiply(Event Healing, 1.666666666666666), Event Healing));
    }
}

rule ("[ana/nade.opy]: Allow self healing during Biotic Grenade") {
    event {
        Ongoing - Each Player;
        All;
        Ana;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999999999999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[ashe.opy]: Add ultimate charge while using BOB") {
    event {
        Ongoing - Each Player;
        All;
        Ashe;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, ult_point_while_ult_active, 0);
        Set Player Variable(Event Player, start_time_ult, Total Time Elapsed);
        Wait Until(Not(Is Using Ultimate(Event Player)), 99999);
        "Check if the user did not switch hero after using B.O.B to add the ult charge"
        If(Compare(Hero Of(Event Player), ==, Hero(Ashe)));
            "Add charge for passive generation and then the ult charge generated from the damage made by Ashe"
            Set Player Variable(Event Player, missing_ult_points, Add(Multiply(5, Subtract(Total Time Elapsed, (Event Player).start_time_ult)), (Event Player).ult_point_while_ult_active));
    }
}

rule ("[ashe.opy]: Calcul of the damage made while BOB is active") {
    event {
        Player Dealt Damage;
        All;
        Ashe;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Victim != Attacker;
    }
    actions {
        If(Array Contains(All Tank Heroes, Hero Of(Victim)));
            Modify Player Variable(Event Player, ult_point_while_ult_active, Add, Multiply(1.3, Event Damage));
        Else;
            Modify Player Variable(Event Player, ult_point_while_ult_active, Add, Event Damage);
    }
}

rule ("[baptiste.opy]: Initialize Baptiste") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Set Ammo(Event Player, 0, 45);
        Set Max Ammo(Event Player, 0, 45);
        Set Ammo(Event Player, 1, 10);
        Set Max Ammo(Event Player, 1, 10);
    }
}

rule ("[baptiste.opy]: Set default immortality field cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999999999999);
        Set Ability Cooldown(Event Player, Button(Ability 2), 25);
    }
}

rule ("[baptiste.opy]: Allow self healing during regenerative burst") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait(5, Ignore Condition);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[baptiste.opy]: Remove instant healing from regenerative burst") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 0);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Healing Dealt(Event Player, 100);
    }
}

rule ("[baptiste.opy]: Buff regenerative burst heals per second") {
    event {
        Player Dealt Healing;
        All;
        Baptiste;
    }
    conditions {
        Event Ability == Button(Ability 1);
        Healee == Event Player;
    }
    actions {
        Heal(Healee, Healer, Subtract(Multiply(Event Healing, 3), Event Healing));
    }
}

rule ("[baptiste.opy]: Buff regenerative burst heals per second") {
    event {
        Player Dealt Healing;
        All;
        Baptiste;
    }
    conditions {
        Event Ability == Button(Ability 1);
        Healee != Event Player;
    }
    actions {
        Heal(Healee, Healer, Subtract(Multiply(Event Healing, 1.5), Event Healing));
    }
}

rule ("[bastion/configuration.opy]: No cooldown on reconfigure (ability 1)") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
    }
}

rule ("[bastion/recon.opy]: Detect recon mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        "built in workshop function for detecting default hero form"
        Is In Alternate Form(Event Player) == False;
    }
    actions {
        Set Player Variable(Event Player, current_configuration, 0);
    }
}

rule ("[bastion/recon.opy]: Initialize recon mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 0;
    }
    actions {
        Set Move Speed(Event Player, 100);
        Set Damage Dealt(Event Player, 100);
        Set Projectile Speed(Event Player, 100);
        Set Projectile Gravity(Event Player, 100);
        Disallow Button(Event Player, Button(Secondary Fire));
        Clear Status(Event Player, Rooted);
        Set Knockback Received(Event Player, 100);
        Allow Button(Event Player, Button(Primary Fire));
    }
}

rule ("[bastion/sentry.opy]: Detect sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is In Alternate Form(Event Player) == True;
        "Sentry mode can only be entered from recon mode"
        (Event Player).current_configuration == 0;
        "prevents incorrectly identifying tank as sentry"
        (Event Player).current_configuration != 2;
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, current_configuration, 1);
    }
}

rule ("[bastion/sentry.opy]: Initialize sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
    }
    actions {
        Set Damage Dealt(Event Player, 125);
        Set Status(Event Player, Null, Rooted, 9999);
        Set Knockback Received(Event Player, 0);
        Disallow Button(Event Player, Button(Secondary Fire));
    }
}

rule ("[bastion/tank.opy]: Detect tank mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, current_configuration, 2);
    }
}

rule ("[bastion/tank.opy]: Initialize tank mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 2;
    }
    actions {
        "move faster in tank mode"
        Set Move Speed(Event Player, 153.84615384615384);
        "deal more damage in tank mode"
        Set Damage Dealt(Event Player, 178.2608695652174);
        "increase grenade travel speed (to mimic tank shells)"
        Set Projectile Speed(Event Player, 150);
        Set Projectile Gravity(Event Player, 5);
        "Disallow firing machine gun"
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Clear Status(Event Player, Rooted);
        Set Knockback Received(Event Player, 100);
    }
}

rule ("[bastion/tank.opy]: startTank()") {
    event {
        Subroutine;
        startTank;
    }
    actions {
        Wait(0.5, Ignore Condition);
        "interrupt ultimate animation right before it completes"
        Cancel Primary Action(Event Player);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        "Go to turret mode"
        Press Button(Event Player, Button(Ability 1));
        "Disable reconfiguring out of turret mode"
        Disallow Button(Event Player, Button(Ability 1));
    }
}

rule ("[bastion/tank.opy]: endTank()") {
    event {
        Subroutine;
        endTank;
    }
    actions {
        If(Is Using Ability 1(Event Player));
            Set Ability Cooldown(Event Player, Button(Ability 1), 0);
            "Go to recon mode"
            Press Button(Event Player, Button(Ability 1));
        End;
        Allow Button(Event Player, Button(Ability 1));
    }
}

rule ("[bastion/tank.opy]: Activate tank mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 2;
    }
    actions {
        Call Subroutine(startTank);
        Wait Until(Not(Is Using Ability 1(Event Player)), 8);
        Call Subroutine(endTank);
    }
}

rule ("[bastion/tank.opy]: Fire tank shells") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 2;
        Is Button Held(Event Player, Button(Primary Fire)) == True;
    }
    actions {
        Allow Button(Event Player, Button(Secondary Fire));
        Press Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Wait(0.016, Ignore Condition);
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), <=, 0), 999999999999999);
        Loop If Condition Is True;
    }
}

rule ("[bastion/tank.opy]: Reload tank shells") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 2;
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        "modify cooldown for tank shell"
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0.75);
        "Wait tank shell reload time"
        Wait(0.75, Ignore Condition);
        "Set tank shell as available"
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
    }
}

rule ("[bastion/repair.opy]: Initialize self repair ability") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Player Variable(Event Player, self_repair_time_left, 3.333333333333333);
    }
}

rule ("[bastion/repair.opy]: startSelfRepair()") {
    event {
        Subroutine;
        startSelfRepair;
    }
    actions {
        Wait(0.5, Ignore Condition);
        Start Heal Over Time(Event Player, Event Player, (Event Player).self_repair_time_left, 90);
        Set Player Variable(Event Player, self_repair_instance, Last Heal Over Time ID);
        "Start depleting"
        Chase Player Variable At Rate(Event Player, self_repair_time_left, 0, 1, Destination and Rate);
    }
}

rule ("[bastion/repair.opy]: stopSelfRepair()") {
    event {
        Subroutine;
        stopSelfRepair;
    }
    actions {
        Stop Heal Over Time((Event Player).self_repair_instance);
        "Stop any ongoing resource modification"
        Stop Chasing Player Variable(Event Player, self_repair_time_left);
        "Wait 1 second cooldown before recharging heal resource"
        Wait(1, Ignore Condition);
        "Start recharging"
        Chase Player Variable At Rate(Event Player, self_repair_time_left, 3.333333333333333, 0.476190476190476, Destination and Rate);
    }
}

rule ("[bastion/repair.opy]: Give ult charge for self repair") {
    event {
        Player Dealt Healing;
        All;
        Bastion;
    }
    conditions {
        Healer == Healee;
    }
    actions {
        Modify Player Variable(Event Player, missing_ult_points, Add, Event Healing);
    }
}

rule ("[bastion/repair.opy]: Start self-repair on ability 2 or secondary fire") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Or(Is Button Held(Event Player, Button(Ability 2)), Is Button Held(Event Player, Button(Secondary Fire))) == True;
        Is Firing Primary(Event Player) == False;
        Health(Event Player) < Max Health(Event Player);
        Is Alive(Event Player) == True;
    }
    actions {
        Call Subroutine(startSelfRepair);
    }
}

rule ("[bastion/repair.opy]: Stop self-repair on key release") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Or(Not(Or(Is Button Held(Event Player, Button(Ability 2)), Is Button Held(Event Player, Button(Secondary Fire)))), Is Firing Primary(Event Player)) == True;
    }
    actions {
        Call Subroutine(stopSelfRepair);
    }
}

rule ("[bastion/repair.opy]: Stop self-repair and hide its GUI on death") {
    event {
        Player Died;
        All;
        Bastion;
    }
    actions {
        Call Subroutine(stopSelfRepair);
    }
}

rule ("[bastion/repair.opy]: Stop self-repair when no healing resource left") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).self_repair_time_left <= 0;
    }
    actions {
        Call Subroutine(stopSelfRepair);
    }
}

rule ("[bastion/repair.opy]: Stop self-repair when full hp") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Health(Event Player) >= Max Health(Event Player);
    }
    actions {
        Call Subroutine(stopSelfRepair);
    }
}

rule ("[bastion/repair.opy]: createSelfRepairGUI()") {
    event {
        Subroutine;
        createSelfRepairGUI;
    }
    actions {
        Create Progress Bar HUD Text(Event Player, Round To Integer(Divide(Multiply(100, (Event Player).self_repair_time_left), 3.333333333333333), To Nearest), Custom String("Self-Repair", Null, Null, Null), Left, 1, Color(Yellow), Color(Yellow), Visible To Values and Color, Default Visibility);
        Set Player Variable(Event Player, self_repair_gui, Last Text ID);
    }
}

rule ("[bastion/repair.opy]: destroySelfRepairGUI()") {
    event {
        Subroutine;
        destroySelfRepairGUI;
    }
    actions {
        Destroy Progress Bar HUD Text((Event Player).self_repair_gui);
    }
}

rule ("[bastion/repair.opy]: Show self-repair GUI") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).self_repair_time_left < 3.333333333333333;
    }
    actions {
        Call Subroutine(createSelfRepairGUI);
    }
}

rule ("[bastion/repair.opy]: Hide self-repair GUI") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).self_repair_time_left >= 3.333333333333333;
    }
    actions {
        Call Subroutine(destroySelfRepairGUI);
    }
}

rule ("[bastion/machine_gun.opy]: Initialize machine gun") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Set Player Variable(Event Player, machine_gun_ammo, 300);
        Set Player Variable(Event Player, machine_gun_reload_timer, 0);
    }
}

rule ("[bastion/machine_gun.opy]: Activate machine gun in sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
    }
    actions {
        Set Player Variable(Event Player, machine_gun_ready, True);
        Stop Chasing Player Variable(Event Player, machine_gun_reload_timer);
    }
}

rule ("[bastion/machine_gun.opy]: createMachineGunGUI()") {
    event {
        Subroutine;
        createMachineGunGUI;
    }
    actions {
        Create Progress Bar HUD Text(Event Player, Round To Integer(Divide(Multiply(100, (Event Player).machine_gun_ammo), 300), To Nearest), Custom String("Ammo: {0}", Round To Integer((Event Player).machine_gun_ammo, Up), Null, Null), Top, 0, Color(Orange), Color(Orange), Visible To Values and Color, Default Visibility);
        Set Player Variable(Event Player, machine_gun_gui, Last Text ID);
    }
}

rule ("[bastion/machine_gun.opy]: destroyMachineGunGUI()") {
    event {
        Subroutine;
        destroyMachineGunGUI;
    }
    actions {
        Destroy Progress Bar HUD Text((Event Player).machine_gun_gui);
    }
}

rule ("[bastion/machine_gun.opy]: start machine gun reload timer") {
    event {
        Subroutine;
        startMachineGunReload;
    }
    actions {
        Abort If(Compare((Event Player).machine_gun_ammo, >=, 300));
        If(Compare((Event Player).current_configuration, ==, 1));
            Small Message(Event Player, Custom String("Reloading . . .", Null, Null, Null));
        End;
        Set Player Variable(Event Player, machine_gun_ready, False);
        Set Player Variable(Event Player, machine_gun_reload_timer, 1.984);
        Chase Player Variable At Rate(Event Player, machine_gun_reload_timer, 0, 1, Destination and Rate);
    }
}

rule ("[bastion/machine_gun.opy]: finish reloading machine gun") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).machine_gun_reload_timer <= 0;
    }
    actions {
        Set Player Variable(Event Player, machine_gun_ammo, 300);
        Set Player Variable(Event Player, machine_gun_ready, True);
        If(Compare((Event Player).current_configuration, ==, 1));
            Small Message(Event Player, Custom String("Done", Null, Null, Null));
    }
}

rule ("[bastion/machine_gun.opy]: Show machine gun gui when in sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
    }
    actions {
        Call Subroutine(createMachineGunGUI);
    }
}

rule ("[bastion/machine_gun.opy]: Hide machine gun gui when not in sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration != 1;
    }
    actions {
        Call Subroutine(destroyMachineGunGUI);
    }
}

rule ("[bastion/machine_gun.opy]: Consume machine gun ammo when shooting") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        Is Firing Primary(Event Player) == True;
    }
    actions {
        Chase Player Variable At Rate(Event Player, machine_gun_ammo, 0, 30, Destination and Rate);
    }
}

rule ("[bastion/machine_gun.opy]: Stop machine gun ammo consumption when not shooting") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        And(Compare((Event Player).current_configuration, ==, 1), Is Firing Primary(Event Player)) == False;
    }
    actions {
        Stop Chasing Player Variable(Event Player, machine_gun_ammo);
    }
}

rule ("[bastion/machine_gun.opy]: Reload machine gun on reload key") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        Is Button Held(Event Player, Button(Reload)) == True;
    }
    actions {
        Call Subroutine(startMachineGunReload);
    }
}

rule ("[bastion/machine_gun.opy]: Reload machine gun if out of ammo") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        (Event Player).machine_gun_ammo <= 0;
    }
    actions {
        Call Subroutine(startMachineGunReload);
    }
}

rule ("[bastion/machine_gun.opy]: Reload machine gun when not in sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration != 1;
    }
    actions {
        Call Subroutine(startMachineGunReload);
    }
}

rule ("[bastion/machine_gun.opy]: Allow machine gun shooting when machine gun ready") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        "gun ready to shoot"
        (Event Player).machine_gun_ready == True;
    }
    actions {
        Allow Button(Event Player, Button(Primary Fire));
    }
}

rule ("[bastion/machine_gun.opy]: Disallow machine gun shooting when machine gun not ready") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        "gun not ready to shoot"
        (Event Player).machine_gun_ready == False;
    }
    actions {
        Disallow Button(Event Player, Button(Primary Fire));
    }
}

rule ("[brigitte/hp.opy]: Initialize Brigitte Hp") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 150);
        Set Player Variable(Event Player, hp_armor, 50);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
    }
}

rule ("[brigitte/bash.opy]: Add stun to shield bash") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Event Ability == Button(Primary Fire);
    }
    actions {
        Set Status(Victim, Event Player, Stunned, 0.75);
    }
}

rule ("[brigitte/bash.opy]: Reduce shield bash distance") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Firing Primary(Event Player) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        "arbitrarily decided based on trial and error"
        Set Move Speed(Event Player, 77.8);
        Wait Until(Not(Is Firing Primary(Event Player)), 1);
        If(Is Using Ultimate(Event Player));
            Set Move Speed(Event Player, 113.04347826086958);
        Else;
            Set Move Speed(Event Player, 100);
    }
}

rule ("[brigitte/bash.opy]: Reduce shield bash damage to OW1") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    conditions {
        Event Ability == Button(Primary Fire);
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Heal(Victim, Null, 45);
    }
}

rule ("[brigitte/rally.opy]: Rally 30% speed boost") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        "30% movement speed buff during ralley"
        Set Move Speed(Event Player, 113.04347826086958);
        Wait Until(Not(Is Using Ultimate(Event Player)), 10);
        Set Move Speed(Event Player, 100);
    }
}

rule ("[brigitte/inspire.opy]: Fix inspire self heal") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    actions {
        Stop Chasing Player Variable(Event Player, inspire_duration);
        Set Player Variable(Event Player, inspire_duration, 0);
        Chase Player Variable At Rate(Event Player, inspire_duration, 6, 1, None);
        Set Player Variable(Event Player, self_healing_percent, 100);
    }
}

rule ("[brigitte/inspire.opy]: No self healing when inspire timer runs out") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        (Event Player).inspire_duration >= 6;
    }
    actions {
        Stop Chasing Player Variable(Event Player, inspire_duration);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[doomfist/hp.opy]: Initialize Doomfist Hp") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 250);
        Set Player Variable(Event Player, hp_armor, 0);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
    }
}

rule ("[doomfist/uppercut.opy]: Initialize uppercut ability") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
        Set Player Variable(Event Player, e_pressed_by_bot, False);
    }
}

rule ("[doomfist/uppercut.opy]: Detect e key press by human") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        (Event Player).e_pressed_by_bot == False;
    }
    actions {
        Set Player Variable(Event Player, pressing_uppercut_key, True);
        Wait Until(Not(Is Button Held(Event Player, Button(Ability 2))), 999999999999999);
        Set Player Variable(Event Player, pressing_uppercut_key, False);
    }
}

rule ("[doomfist/uppercut.opy]: Control flow for uppercut") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).pressing_uppercut_key == True;
        (Event Player).is_using_slam == False;
        Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
        "@Condition not eventPlayer.hasStatusEffect(Status.HACKED) # Ensure Doomfist is not hacked\n Ensure Doomfist is not frozen"
        Has Status(Event Player, Frozen) == False;
        "Ensure Doomfist is not knocked down"
        Has Status(Event Player, Knocked Down) == False;
        "Ensure Doomfist is not asleep"
        Has Status(Event Player, Asleep) == False;
        "Ensure Doomfist is not stunned"
        Has Status(Event Player, Stunned) == False;
    }
    actions {
        Call Subroutine(executeUppercut);
    }
}

rule ("[doomfist/uppercut.opy]: executeUppercut()") {
    event {
        Subroutine;
        executeUppercut;
    }
    actions {
        "Doomfist phases through enemies during uppercut"
        Disable Movement Collision With Players(Event Player);
        "Uppercut physics\n Start of uppercut"
        Set Player Variable(Event Player, is_using_uppercut, True);
        "Cancel current momentum"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
        "Step Forward"
        Apply Impulse(Event Player, Normalize(Multiply(Facing Direction Of(Event Player), Add(Forward, Left))), 5, To World, Incorporate Contrary Motion);
        "Override gravity during uppercut"
        Set Gravity(Event Player, 0);
        "Deny player from inputting movement commands"
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Wait(0.15, Ignore Condition);
        "Uppercut"
        Apply Impulse(Event Player, Up, 40, To World, Incorporate Contrary Motion);
        Wait(0.1, Ignore Condition);
        Apply Impulse(Event Player, Down, Max(0, Speed Of In Direction(Event Player, Up)), To World, Incorporate Contrary Motion);
        "End of uppercut"
        Set Player Variable(Event Player, is_using_uppercut, False);
        Wait(0.016, Ignore Condition);
        Apply Impulse(Event Player, Up, 2.5, To World, Incorporate Contrary Motion);
        Set Gravity(Event Player, 0);
        Enable Movement Collision With Players(Event Player);
        Wait(0.35, Ignore Condition);
        Stop Forcing Throttle(Event Player);
        Wait(0.15, Ignore Condition);
        Set Gravity(Event Player, 50);
        Wait(0.25, Ignore Condition);
        Set Gravity(Event Player, 100);
    }
}

rule ("[doomfist/uppercut.opy]: Play uppercut VFX") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_uppercut == True;
    }
    actions {
        Play Effect(All Players(All Teams), Explosion Sound, Team Of(Event Player), Event Player, 100);
        Play Effect(All Players(All Teams), Debuff Impact Sound, Team Of(Event Player), Event Player, 100);
        Play Effect(All Players(All Teams), Ring Explosion Sound, Team Of(Event Player), Event Player, 100);
    }
}

rule ("[doomfist/uppercut.opy]: Set uppercut cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_uppercut == True;
    }
    actions {
        Wait Until(Compare((Event Player).is_using_uppercut, ==, False), 999999999999999);
        Set Ability Cooldown(Event Player, Button(Ability 2), 6);
    }
}

rule ("[doomfist/uppercut.opy]: Disable abilities when uppercutting") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_uppercut == True;
    }
    actions {
        "Doomfist cannot melee during uppercut"
        Set Melee Enabled(Event Player, False);
        "Doomfist cannot shoot during uppercut"
        Set Primary Fire Enabled(Event Player, False);
        "Doomfist cannot punch during uppercut"
        Set Secondary Fire Enabled(Event Player, False);
        Wait Until(Compare((Event Player).is_using_uppercut, ==, False), 999999999999999);
        Set Melee Enabled(Event Player, True);
        Set Primary Fire Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, True);
    }
}

rule ("[doomfist/uppercut.opy]: Detect uppercut victims") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        "Enemy doomfist using uppercut"
        ((Event Player).enemy_doomfist_player).is_using_uppercut == True;
        "Victim within uppercut hitbox range"
        Distance Between((Event Player).enemy_doomfist_player, Event Player) <= 5;
        "Victim in los of doomfist"
        Is In Line of Sight((Event Player).enemy_doomfist_player, Event Player, Barriers Do Not Block LOS) == True;
        "Victim visible to doomfist"
        Angle Between Vectors(Normalize(Multiply(Facing Direction Of((Event Player).enemy_doomfist_player), Add(Forward, Left))), Direction Towards((Event Player).enemy_doomfist_player, Event Player)) <= 90;
        "Enemy doomfist alive"
        Is Alive((Event Player).enemy_doomfist_player) == True;
        "Victim is alive"
        Is Alive(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, is_hit_by_uppercut, True);
    }
}

rule ("[doomfist/uppercut.opy]: Uppercut victim movement physics") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_hit_by_uppercut == True;
    }
    actions {
        "Lose movement control"
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Apply Impulse(Event Player, Up, 13.5, To Player, Cancel Contrary Motion XYZ);
        Apply Impulse(Event Player, Normalize(Multiply(Facing Direction Of((Event Player).enemy_doomfist_player), Add(Forward, Left))), 8.5, To World, Cancel Contrary Motion XYZ);
        Wait(0.6, Ignore Condition);
        "Regain movement control"
        Stop Forcing Throttle(Event Player);
        Set Player Variable(Event Player, is_hit_by_uppercut, False);
    }
}

rule ("[doomfist/uppercut.opy]: Damage uppercut victims") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_hit_by_uppercut == True;
    }
    actions {
        Damage(Event Player, (Event Player).enemy_doomfist_player, 50);
        Set Environment Credit Player(Event Player, (Event Player).enemy_doomfist_player);
    }
}

rule ("[doomfist/uppercut.opy]: Play uppercut hit VFX") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_hit_by_uppercut == True;
    }
    actions {
        Play Effect(All Players(All Teams), Bad Explosion, Color(White), Event Player, 1);
    }
}

rule ("[doomfist/slam.opy]: Initialize slam ability") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 1));
        Set Player Variable(Event Player, shift_pressed_by_bot, False);
    }
}

rule ("[doomfist/slam.opy]: Detect shift key press by human") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 1)) == True;
        (Event Player).shift_pressed_by_bot == False;
    }
    actions {
        Set Player Variable(Event Player, pressing_slam_key, True);
        Wait Until(Not(Is Button Held(Event Player, Button(Ability 1))), 999999999999999);
        Set Player Variable(Event Player, pressing_slam_key, False);
    }
}

rule ("[doomfist/slam.opy]: Control flow for slam") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).pressing_slam_key == True;
        (Event Player).is_using_uppercut == False;
        Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
        "@Condition not eventPlayer.hasStatusEffect(Status.HACKED) # Ensure Doomfist is not hacked\n Ensure Doomfist is not frozen"
        Has Status(Event Player, Frozen) == False;
        "Ensure Doomfist is not knocked down"
        Has Status(Event Player, Knocked Down) == False;
        "Ensure Doomfist is not asleep"
        Has Status(Event Player, Asleep) == False;
        "Ensure Doomfist is not stunned"
        Has Status(Event Player, Stunned) == False;
    }
    actions {
        Call Subroutine(executeSlam);
    }
}

rule ("[doomfist/slam.opy]: Detect ground slam") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Update Every Frame(Compare(Altitude Of(Event Player), <, 3)) != False;
    }
    actions {
        Set Player Variable(Event Player, slam_to_use, 0);
    }
}

rule ("[doomfist/slam.opy]: Detect indicator slam") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Update Every Frame(Compare(Altitude Of(Event Player), >=, 3)) != False;
    }
    actions {
        Set Player Variable(Event Player, slam_to_use, 1);
    }
}

rule ("[doomfist/slam.opy]: Start tracking indicator slam destination") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).slam_to_use == 1;
        Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        Chase Player Variable At Rate(Event Player, proto_indicator_slam_position, Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(15, Facing Direction Of(Event Player))), Null, Null, First Of(Null)), 9999, Destination and Rate);
        Chase Player Variable At Rate(Event Player, indicator_slam_position, Ray Cast Hit Position((Event Player).proto_indicator_slam_position, Add((Event Player).proto_indicator_slam_position, Multiply(5, Down)), Null, All Players(All Teams), False), 9999, Destination and Rate);
    }
}

rule ("[doomfist/slam.opy]: Stop tracking indicator slam destination") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        And(And(Compare((Event Player).slam_to_use, ==, 1), Compare(Ability Cooldown(Event Player, Button(Ability 1)), <=, 0)), Not(Is Using Ability 1(Event Player))) == False;
    }
    actions {
        Stop Chasing Player Variable(Event Player, proto_indicator_slam_position);
        Stop Chasing Player Variable(Event Player, indicator_slam_position);
    }
}

rule ("[doomfist/slam.opy]: executeSlam()") {
    event {
        Subroutine;
        executeSlam;
    }
    actions {
        "clear slammed victims"
        Set Player Variable(Event Player, slammed_victims, Empty Array);
        If(Compare((Event Player).slam_to_use, ==, 1));
            "Only execute when indicator slam is valid"
            If(Compare(Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position), <, 5));
                Call Subroutine(initiateIndicatorSlam);
            End;
        Else;
            Call Subroutine(initiateGroundSlam);
        End;
        If(Compare((Event Player).is_using_slam, ==, True));
            Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
            Set Player Variable(Event Player, is_using_slam, False);
            Set Ability Cooldown(Event Player, Button(Ability 1), 6);
        End;
    }
}

rule ("[doomfist/slam.opy]: InitiateGroundSlam()") {
    event {
        Subroutine;
        initiateGroundSlam;
    }
    actions {
        Set Player Variable(Event Player, is_using_slam, True);
        Set Gravity(Event Player, 0);
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Call Subroutine(startSlamAnimation);
        "apply custom momentum"
        Apply Impulse(Event Player, Add(Normalize(Multiply(Facing Direction Of(Event Player), Add(Forward, Left))), Vector(0, 0.075, 0)), 16, To World, Incorporate Contrary Motion);
        Wait(0.3, Ignore Condition);
        Set Gravity(Event Player, 100);
        Wait Until(Or(Is On Ground(Event Player), Not(Is Using Ability 1(Event Player))), 999999999999999);
        Stop Forcing Throttle(Event Player);
    }
}

rule ("[doomfist/slam.opy]: InitiateIndicatorSlam()") {
    event {
        Subroutine;
        initiateIndicatorSlam;
    }
    actions {
        Stop Chasing Player Variable(Event Player, proto_indicator_slam_position);
        Stop Chasing Player Variable(Event Player, indicator_slam_position);
        Set Player Variable(Event Player, proto_indicator_slam_position, Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(15, Facing Direction Of(Event Player))), Null, Null, First Of(Null)));
        Set Player Variable(Event Player, indicator_slam_position, Ray Cast Hit Position((Event Player).proto_indicator_slam_position, Add((Event Player).proto_indicator_slam_position, Multiply(5, Down)), Null, All Players(All Teams), False));
        Set Player Variable(Event Player, indicator_slam_direction, Direction Towards(Position Of(Event Player), (Event Player).indicator_slam_position));
        Set Player Variable(Event Player, is_using_slam, True);
        Set Gravity(Event Player, 0.001);
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Call Subroutine(startSlamAnimation);
        Set Player Variable(Event Player, current_position, Position Of(Event Player));
        Chase Player Variable At Rate(Event Player, current_position, (Event Player).indicator_slam_position, 25, None);
        Start Forcing Player Position(Event Player, (Event Player).current_position, True);
        "Helps prevent clipping through map geometry"
        Apply Impulse(Event Player, (Event Player).indicator_slam_direction, 25, To World, Cancel Contrary Motion XYZ);
        Wait Until(Or(Compare(Distance Between((Event Player).current_position, (Event Player).indicator_slam_position), <=, 0.01), Not(Is Using Ability 1(Event Player))), 999999999999999);
        Stop Forcing Player Position(Event Player);
        Stop Chasing Player Variable(Event Player, current_position);
        Stop Forcing Throttle(Event Player);
        Set Gravity(Event Player, 100);
        "cancel current momentum"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
    }
}

rule ("[doomfist/slam.opy]: startSlamAnimation()") {
    event {
        Subroutine;
        startSlamAnimation;
    }
    actions {
        "Start slam animation"
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        Allow Button(Event Player, Button(Ability 1));
        Set Player Variable(Event Player, shift_pressed_by_bot, True);
        Press Button(Event Player, Button(Ability 1));
        Set Player Variable(Event Player, shift_pressed_by_bot, False);
        Disallow Button(Event Player, Button(Ability 1));
        Wait(0.016, Ignore Condition);
        "Cancel current momentum"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
    }
}

rule ("[doomfist/slam.opy]: Calculate slam damage based on air time") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_slam == True;
    }
    actions {
        Set Player Variable(Event Player, slam_damage, 0);
        Wait Until(Update Every Frame(Not(Is On Ground(Event Player))), 999999999999999);
        Call Subroutine(createSlamDamageGui);
        Chase Player Variable At Rate(Event Player, slam_damage, 125, 100, None);
        Wait Until(Update Every Frame(Is On Ground(Event Player)), 999999999999999);
        Stop Chasing Player Variable(Event Player, slam_damage);
        Wait(1, Ignore Condition);
        Call Subroutine(destroySlamDamageGui);
    }
}

rule ("[doomfist/slam.opy]: createSlamDamageGui()") {
    event {
        Subroutine;
        createSlamDamageGui;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).slam_damage, Down), Null, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.2, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, slam_damage_text_entity, Last Text ID);
    }
}

rule ("[doomfist/slam.opy]: destroySlamDamageGui()") {
    event {
        Subroutine;
        destroySlamDamageGui;
    }
    actions {
        Destroy In-World Text((Event Player).slam_damage_text_entity);
        Set Player Variable(Event Player, slam_damage_text_entity, Null);
    }
}

rule ("[doomfist/slam.opy]: Remove OW2 slam damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        "Ability used to damage player is Seismic Slam"
        Event Ability == Button(Ability 1);
    }
    actions {
        Heal(Victim, Null, Event Damage);
    }
}

rule ("[doomfist/slam.opy]: Find slammed victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        "Ability used to damage player is Seismic Slam"
        Event Ability == Button(Ability 1);
        1 <= Distance Between(Attacker, Victim);
        Distance Between(Attacker, Victim) <= 8;
    }
    actions {
        "TODO add condition to check victim in 60 degree cone"
        Modify Player Variable(Attacker, slammed_victims, Append To Array, Victim);
    }
}

rule ("[doomfist/slam.opy]: Slammed victims damage and pull/push effects") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        "Ability used to damage player is Seismic Slam"
        Event Ability == Button(Ability 1);
        Array Contains((Attacker).slammed_victims, Victim) == True;
    }
    actions {
        "Custom slam damage"
        Damage(Victim, Attacker, Round To Integer((Attacker).slam_damage, Down));
        Set Gravity(Victim, 50);
        "Boop slammed victims up"
        Apply Impulse(Victim, Up, 5.25, To World, Cancel Contrary Motion XYZ);
        "Push/Pull slammed victims; multiply pull magnitude by 1.5 to counteract air resistance"
        Apply Impulse(Victim, Direction Towards(Victim, Attacker), Multiply(1.5, Subtract(Distance Between(Victim, Attacker), 4)), To World, Cancel Contrary Motion XYZ);
        Set Gravity(Victim, 100);
    }
}

rule ("[doomfist/slam.opy]: Slam indicator VFX") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).slam_to_use == 1;
        Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
        Is Using Ability 1(Event Player) == False;
        Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position) < 5;
    }
    actions {
        Call Subroutine(createSlamIndicatorGui);
        Wait Until(Or(Or(Or(Compare((Event Player).slam_to_use, !=, 1), Compare(Ability Cooldown(Event Player, Button(Ability 1)), >, 0)), Is Using Ability 1(Event Player)), Compare(Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position), >=, 5)), 999999999999999);
        Call Subroutine(destroySlamIndicatorGui);
    }
}

rule ("[doomfist/slam.opy]: createSlamIndicatorGui()") {
    event {
        Subroutine;
        createSlamIndicatorGui;
    }
    actions {
        For Global Variable(i, 0, 2, 1);
            Create Beam Effect(If-Then-Else(And(And(And(Compare((Event Player).slam_to_use, ==, 1), Compare(Ability Cooldown(Event Player, Button(Ability 1)), <=, 0)), Not(Is Using Ability 1(Event Player))), Compare(Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position), <, 5)), Event Player, Null), Good Beam, Update Every Frame(Add((Event Player).indicator_slam_position, World Vector Of(Add(Multiply(Cosine From Degrees(Subtract(30, Multiply(Evaluate Once(Global.i), 60))), Forward), Multiply(Sine From Degrees(Subtract(30, Multiply(Evaluate Once(Global.i), 60))), Left)), Event Player, Rotation))), Update Every Frame(Add((Event Player).indicator_slam_position, Multiply(8, World Vector Of(Add(Multiply(Cosine From Degrees(Subtract(30, Multiply(Evaluate Once(Global.i), 60))), Forward), Multiply(Sine From Degrees(Subtract(30, Multiply(Evaluate Once(Global.i), 60))), Left)), Event Player, Rotation)))), Color(Blue), Visible To Position and Radius);
            Modify Player Variable(Event Player, indicator_entity, Append To Array, Last Created Entity);
        End;
    }
}

rule ("[doomfist/slam.opy]: destroySlamIndicatorGui()") {
    event {
        Subroutine;
        destroySlamIndicatorGui;
    }
    actions {
        For Global Variable(i, 0, Count Of((Event Player).indicator_entity), 1);
            Destroy Effect(Value In Array((Event Player).indicator_entity, Global.i));
        End;
        Set Player Variable(Event Player, indicator_entity, Empty Array);
    }
}

rule ("[doomfist/punch.opy]: Initialize rocket punch ability") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Set Player Variable(Event Player, punched_victims, Empty Array);
        Set Player Variable(Event Player, wall_impacted_victims, Empty Array);
    }
}

rule ("[doomfist/punch.opy]: Initialize rocket punch") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions {
        Set Player Variable(Event Player, punched_victims, Empty Array);
        Set Player Variable(Event Player, wall_impacted_victims, Empty Array);
        Set Player Variable(Event Player, punch_charge_time, 0);
        Chase Player Variable At Rate(Event Player, punch_charge_time, 1.4, 1, None);
        Wait Until(Not(Is Button Held(Event Player, Button(Secondary Fire))), 999999999999999);
        Stop Chasing Player Variable(Event Player, punch_charge_time);
    }
}

rule ("[doomfist/punch.opy]: Find wall impacted victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Attacker).punched_victims, Victim) == True;
        Array Contains((Attacker).wall_impacted_victims, Victim) == False;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Add(Multiply(82.78145695364239, Subtract((Event Player).punch_charge_time, 1.4)), 150), Event Damage));
        Modify Player Variable(Attacker, wall_impacted_victims, Append To Array, Victim);
    }
}

rule ("[doomfist/punch.opy]: Find punched victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Attacker).punched_victims, Victim) == False;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Add(Multiply(41.390728476821195, Subtract((Event Player).punch_charge_time, 1.4)), 100), Event Damage));
        Modify Player Variable(Attacker, punched_victims, Append To Array, Victim);
    }
}

rule ("[doomfist/punch.opy]: Remove Empowered Punch from ultimate") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        "eventPlayer.disallowButton(Button.ABILITY_1)\n eventPlayer.disallowButton(Button.ABILITY_2)"
        Wait Until(Is Button Held(Event Player, Button(Primary Fire)), 4.8);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Start Holding Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Status(Event Player, Null, Stunned, 0.016);
        Stop Holding Button(Event Player, Button(Secondary Fire));
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
        Set Secondary Fire Enabled(Event Player, False);
        Wait(0.016, Ignore Condition);
        Set Secondary Fire Enabled(Event Player, True);
        "eventPlayer.allowButton(Button.ABILITY_1)\n eventPlayer.allowButton(Button.ABILITY_2)"
        Allow Button(Event Player, Button(Secondary Fire));
    }
}

rule ("[doomfist/punch.opy]: Remove stun from wall impact") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Event Player).wall_impacted_victims, Victim) == True;
    }
    actions {
        Clear Status(Victim, Stunned);
    }
}

rule ("[doomfist/meteor.opy]: Deal OW1 Meteor Strike damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Ultimate);
        Event Damage < 200;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Add(200, Multiply(2.176470588235294, Subtract(Event Damage, 100))), Event Damage));
    }
}

rule ("[doomfist/cannon.opy]: Deal OW1 hand cannon damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        "Deal additional damage to match OW1 damage"
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.2), Event Damage));
    }
}

rule ("[doomfist.opy]: Initialize Doomfist") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Set Player Variable(All Players(Team Of(Event Player)), friendly_doomfist_player, Event Player);
        Set Player Variable(All Players(Opposite Team Of(Team Of(Event Player))), enemy_doomfist_player, Event Player);
    }
}

rule ("[dva/hp.opy]: Correct DVa mech health") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is In Alternate Form(Event Player) == False;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 300);
        Set Player Variable(Event Player, hp_armor, 300);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
    }
}

rule ("[dva/hp.opy]: Correct DVa pilot health") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is In Alternate Form(Event Player) == True;
    }
    actions {
        Call Subroutine(clearCustomHealth);
    }
}

rule ("[dva/booster.opy]: Set default booster cooldown") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 4);
    }
}

rule ("[dva/booster.opy]: Decouple melee button from activating melee animation during booster") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Melee));
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Allow Button(Event Player, Button(Melee));
    }
}

rule ("[dva/booster.opy]: Cancel booster if melee pressed") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Button Held(Event Player, Button(Melee)) == True;
    }
    actions {
        Press Button(Event Player, Button(Ability 1));
        Allow Button(Event Player, Button(Melee));
        Press Button(Event Player, Button(Melee));
        Disallow Button(Event Player, Button(Melee));
    }
}

rule ("[dva/booster.opy]: Reduce boosters damage") {
    event {
        Player Dealt Damage;
        All;
        D.Va;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Heal(Victim, Null, 5);
    }
}

rule ("[dva/missile.opy]: Set default missile cooldown") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999999999999);
        Set Ability Cooldown(Event Player, Button(Ability 2), 8);
    }
}

rule ("[echo.opy]: Tank armor, shields and health for every tank") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(D.Va)), Array(300, 300, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Wrecking Ball)), Array(500, 100, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Orisa)), Array(200, 250, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Reinhardt)), Array(300, 200, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Roadhog)), Array(600, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Sigma)), Array(300, 0, 100));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Winston)), Array(350, 150, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Zarya)), Array(200, 0, 200));
    }
}

rule ("[echo.opy]: Deal OW1 echo focusing beam under 50% hp") {
    event {
        Player Dealt Damage;
        All;
        Echo;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
        Divide(Multiply(100, Health(Victim)), Max Health(Victim)) < 50;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.142857142857142), Event Damage));
    }
}

rule ("[echo.opy]: Set Life for echo when duplicating a tank") {
    event {
        Ongoing - Each Player;
        All;
        Echo;
    }
    conditions {
        Is Duplicating(Event Player) == True;
        Array Contains(All Tank Heroes, Hero Being Duplicated(Event Player)) == True;
        Hero Being Duplicated(Event Player) != Hero(Doomfist);
    }
    actions {
        Set Player Variable(Event Player, hero_id_duplicated, Index Of Array Value(All Heroes, Hero Being Duplicated(Event Player)));
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, hp_health, First Of(Value In Array(Global.health_pool, (Event Player).hero_id_duplicated)));
        Set Player Variable(Event Player, hp_armor, Value In Array(Value In Array(Global.health_pool, (Event Player).hero_id_duplicated), 1));
        Set Player Variable(Event Player, hp_shields, Value In Array(Value In Array(Global.health_pool, (Event Player).hero_id_duplicated), 2));
        Call Subroutine(applyCustomHealth);
        Wait Until(Not(Is Duplicating(Event Player)), 15);
        Call Subroutine(clearCustomHealth);
    }
}

rule ("[genji.opy]: Initialize Genji") {
    event {
        Ongoing - Each Player;
        All;
        Genji;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Set Ammo(Event Player, 0, 30);
        Set Max Ammo(Event Player, 0, 30);
    }
}

rule ("[genji.opy]: Deal OW1 shuriken damage") {
    event {
        Player Dealt Damage;
        All;
        Genji;
    }
    conditions {
        Or(Compare(Event Ability, ==, Button(Primary Fire)), Compare(Event Ability, ==, Button(Secondary Fire))) == True;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.074074074074074), Event Damage));
    }
}

rule ("[hanzo.opy]: Deal OW1 primary fire damage") {
    event {
        Player Dealt Damage;
        All;
        Hanzo;
    }
    conditions {
        Or(Compare(Event Ability, ==, Button(Primary Fire)), Compare(Event Ability, ==, Button(Ability 1))) == True;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.041666666666666), Event Damage));
    }
}

rule ("[hanzo.opy]: Deal OW1 storm arrow damage") {
    event {
        Player Dealt Damage;
        All;
        Hanzo;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.076923076923076), Event Damage));
    }
}

rule ("[illari.opy]: Allow self healing during Pylon") {
    event {
        Ongoing - Each Player;
        All;
        Illari;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999999999999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[junkerqueen.opy]: Initialize Junkerqueen") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Set Knockback Received(Event Player, 142.85714285714286);
    }
}

rule ("[junkrat.opy]: Initialize Junkrat") {
    event {
        Ongoing - Each Player;
        All;
        Junkrat;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        "Reduce damage to the trap"
        Set Damage Dealt(Event Player, 80);
    }
}

rule ("[junkrat.opy]: Deal extra damage on ability other than steel trap and increase root duration.") {
    event {
        Player Dealt Damage;
        All;
        Junkrat;
    }
    actions {
        If(Compare(Event Ability, ==, Button(Ability 1)));
            "Increase damage for concussion mine"
            Damage(Victim, Attacker, Subtract(Add(Multiply(Add(Event Damage, Multiply(Divide(Subtract(Event Damage, 30), 80), 10)), 1.25), 1), Event Damage));
        Else If(Compare(Event Ability, !=, Button(Ability 2)));
            "Increase damage for every ability except trap and conccusion mine"
            Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.25), Event Damage));
        Else;
            "Increase root duration"
            Set Status(Victim, Attacker, Rooted, 3);
    }
}

rule ("[kiriko.opy]: Allow self healing during Suzu") {
    event {
        Ongoing - Each Player;
        All;
        Kiriko;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999999999999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[lifeweaver.opy]: Allow self healing during Rejuvanating Dash") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        "[TODO] Replace with better condition"
        Is Jumping(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        "[TODO] Replace with better condition"
        Wait Until(Not(Is Jumping(Event Player)), 999999999999999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[lifeweaver.opy]: Allow self healing during Tree of Life") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[lucio.opy]: Handle lucio self healing while amp is not active and supp passive is active") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 2(Event Player) == False;
        Is Using Ability 1(Event Player) == False;
        (Event Player).support_passive_active != False;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 48);
    }
}

rule ("[lucio.opy]: Handle lucio self healing while amp is not active and support passive inactive") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 2(Event Player) == False;
        Is Using Ability 1(Event Player) == False;
        (Event Player).support_passive_active == False;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 120);
    }
}

rule ("[lucio.opy]: Handle lucio self when amp is active and supp passive is active") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
        Is Using Ability 1(Event Player) == False;
        (Event Player).support_passive_active != False;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 68.42105263157895);
    }
}

rule ("[lucio.opy]: Handle lucio self when amp is active and supp passive is inactive") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
        Is Using Ability 1(Event Player) == False;
        (Event Player).support_passive_active == False;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
    }
}

rule ("[lucio.opy]: If lucio uses speed aura remove self healing") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[mccree.opy]: Set Cassidy hp") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 225);
        Set Player Variable(Event Player, hp_armor, 0);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
    }
}

rule ("[mccree.opy]: Initialize flashbang ability") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
    }
}

rule ("[mccree.opy]: Throw projectile when pressing e") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
        "Ensure Cassidy is not rolling"
        Is Using Ability 1(Event Player) == False;
        "Ensure Cassidy is not hacked"
        Has Status(Event Player, Hacked) == False;
        "Ensure Cassidy is not frozen"
        Has Status(Event Player, Frozen) == False;
        "Ensure Cassidy is not knocked down"
        Has Status(Event Player, Knocked Down) == False;
        "Ensure Cassidy is not asleep"
        Has Status(Event Player, Asleep) == False;
        "Ensure Cassidy is not stunned"
        Has Status(Event Player, Stunned) == False;
    }
    actions {
        Create Projectile(Orb Projectile, Event Player, Null, Null, To World, Damage, Opposite Team Of(Team Of(Event Player)), 25, 1, 3, Bad Explosion, Explosion Sound, 0, 30, 0.233333333333333, 0, 0, 1);
        Set Ability Cooldown(Event Player, Button(Ability 2), 10);
    }
}

rule ("[mccree.opy]: Stun flashed enemy") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Event Ability == 0;
        "This check is needed to ensure that the damage source is flashbang"
        Event Damage >= 15;
        Or(Compare(Hero Of(Attacker), ==, Hero(Cassidy)), Compare(Hero Of(Attacker), ==, Hero(Genji))) == True;
    }
    actions {
        Set Status(Victim, Event Player, Stunned, 0.8);
    }
}

rule ("[mccree.opy]: Remove damage reduction during roll") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Damage Received(Event Player, 200);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Damage Received(Event Player, 100);
    }
}

rule ("[mccree.opy]: Remove damage reduction during deadeye") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Received(Event Player, 166.66666666666666);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Damage Received(Event Player, 100);
    }
}

rule ("[mei.opy]: Initialize Mei") {
    event {
        Ongoing - Each Player;
        All;
        Mei;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Set Ammo(Event Player, 0, 120);
        Set Max Ammo(Event Player, 0, 120);
    }
}

rule ("[mei.opy]: Track freezing on enemy") {
    event {
        Player Dealt Damage;
        All;
        Mei;
    }
    conditions {
        Event Ability == Button(Primary Fire);
        (Victim).freeze_progress < 100;
    }
    actions {
        Stop Chasing Player Variable(Victim, freeze_slow_linger_time);
        "victims started taking freeze damage"
        If(Compare((Victim).freeze_progress, ==, 0));
            Set Player Variable(Victim, freeze_progress, 20);
        Else;
            Modify Player Variable(Victim, freeze_progress, Add, 2.85);
        End;
        Set Player Variable(Victim, freeze_move_penalty, If-Then-Else(Compare((Victim).freeze_progress, <, 70), (Victim).freeze_progress, 70));
        "victim.setMoveSpeed(100-victim.freeze_move_penalty)"
        Set Player Variable(Victim, freeze_slow_linger_time, 0);
        Chase Player Variable At Rate(Victim, freeze_slow_linger_time, 1, 1, None);
    }
}

rule ("[mei.opy]: Freeze enemy") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        (Victim).freeze_progress >= 100;
    }
    actions {
        Set Status(Victim, Event Player, Frozen, 1.3);
        Wait Until(Not(Has Status(Victim, Frozen)), 999999999999999);
        Call Subroutine(clearFreezeEffect);
    }
}

rule ("[mei.opy]: clear freeze after exceeding linger time") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).freeze_slow_linger_time >= 1;
    }
    actions {
        Call Subroutine(clearFreezeEffect);
    }
}

rule ("[mei.opy]: clearFreezeEffect()") {
    event {
        Subroutine;
        clearFreezeEffect;
    }
    actions {
        Stop Chasing Player Variable(Event Player, freeze_slow_linger_time);
        Set Move Speed(Event Player, 100);
        Set Player Variable(Event Player, freeze_progress, 0);
    }
}

rule ("[mercy/ammo.opy]: Initialize Mercy clip size") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Set Ammo(Event Player, 0, 20);
        Set Max Ammo(Event Player, 0, 20);
    }
}

rule ("[mercy/guardian.opy]: Initialize Guardian Angel Ability") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Set Player Variable(Event Player, is_using_guardian_angel, False);
        Set Player Variable(Event Player, is_slingshotting, False);
    }
}

rule ("[mercy/guardian.opy]: Detect Guardian Angel activation") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Speed Of(Event Player) >= 8.5;
    }
    actions {
        Set Player Variable(Event Player, is_using_guardian_angel, True);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Player Variable(Event Player, is_using_guardian_angel, False);
    }
}

rule ("[mercy/guardian.opy]: Disable jump and crouch during guardian angel") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_using_guardian_angel != False;
    }
    actions {
        Disallow Button(Event Player, Button(Jump));
        Disallow Button(Event Player, Button(Crouch));
        Wait Until(Not((Event Player).is_using_guardian_angel), 999999999999999);
        Allow Button(Event Player, Button(Jump));
        Allow Button(Event Player, Button(Crouch));
    }
}

rule ("[mercy/guardian.opy]: Activate GA slingshot") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_using_guardian_angel == True;
        "wait until below acts as the final condition for activating slingshot"
        Is Button Held(Event Player, Button(Jump)) == False;
    }
    actions {
        Wait Until(Is Button Held(Event Player, Button(Jump)), 999999999999999);
        "Cancel GA by pressing and unpressing button"
        Start Holding Button(Event Player, Button(Ability 1));
        Stop Holding Button(Event Player, Button(Ability 1));
        Set Player Variable(Event Player, slingshot_velocity, Velocity Of(Event Player));
        Set Player Variable(Event Player, is_slingshotting, True);
        Wait Until(Or(Not(Is Button Held(Event Player, Button(Jump))), Is On Ground(Event Player)), 0.33);
        Set Player Variable(Event Player, is_slingshotting, False);
    }
}

rule ("[mercy/guardian.opy]: Apply upwards momentum when starting slingshot") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_slingshotting == True;
    }
    actions {
        Apply Impulse(Event Player, Up, 6, To World, Incorporate Contrary Motion);
    }
}

rule ("[mercy/guardian.opy]: Give speed boost during slingshot") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_slingshotting == True;
    }
    actions {
        While((Event Player).is_slingshotting);
            Apply Impulse(Event Player, (Event Player).slingshot_velocity, 0.6, To World, Incorporate Contrary Motion);
            Wait(0.016, Ignore Condition);
        End;
    }
}

rule ("[mercy/guardian.opy]: Force angelic descent during slingshot") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_slingshotting == True;
    }
    actions {
        Allow Button(Event Player, Button(Jump));
        Start Holding Button(Event Player, Button(Jump));
        Wait Until(Not(Is Button Held(Event Player, Button(Jump))), 99999);
        Stop Holding Button(Event Player, Button(Jump));
    }
}

rule ("[mercy/guardian.opy]: Slingshot GA cooldown logic") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).is_slingshotting == True;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        Wait Until(Or(Not(Is Button Held(Event Player, Button(Ability 1))), Is On Ground(Event Player)), 999999999999999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 1.5);
        Set Ability 1 Enabled(Event Player, True);
    }
}

rule ("[moira.opy]: Deny fade during coalescence") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Ability 1 Enabled(Event Player, True);
    }
}

rule ("[moira.opy]: Allow self healing during Biotic Grasp") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999999999999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[moira.opy]: Allow self healing during Biotic Orb") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
        Is Button Held(Event Player, Button(Primary Fire)) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait(7, Ignore Condition);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[moira.opy]: Allow self healing during Coalescence") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[orisa/hp.opy]: Initialize Orisa Hp") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 200);
        Set Player Variable(Event Player, hp_armor, 250);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
    }
}

rule ("[orisa/supercharger.opy]: Initialize supercharger ability") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ultimate));
        Set Player Variable(Event Player, is_using_supercharger, False);
    }
}

rule ("[orisa/supercharger.opy]: Trigger Supercharger start") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Ultimate)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is On Ground(Event Player) == True;
    }
    actions {
        "Destroy any existing Supercharger"
        Call Subroutine(endSupercharger);
        "Start supercharger"
        Call Subroutine(startSupercharger);
    }
}

rule ("[orisa/supercharger.opy]: Trigger Supercharger end") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).orisa_supercharger_uptime >= 15;
    }
    actions {
        Call Subroutine(endSupercharger);
    }
}

rule ("[orisa/supercharger.opy]: startSupercharger()") {
    event {
        Subroutine;
        startSupercharger;
    }
    actions {
        Set Ultimate Charge(Event Player, 0);
        Set Ultimate Ability Enabled(Event Player, False);
        Communicate(Event Player, Voice Line Up);
        "Supercharge GUI"
        Set Player Variable(Event Player, orisa_supercharger_position, Add(Position Of(Event Player), Multiply(0.5, Up)));
        Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).orisa_supercharger_position, 0.5, None);
        Set Player Variable(Event Player, orisa_supercharger_entity, Last Created Entity);
        "Supercharge Effect"
        Play Effect(All Players(All Teams), Good Explosion, Color(Green), (Event Player).orisa_supercharger_position, 3);
        Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Green), (Event Player).orisa_supercharger_position, 200);
        "Start supercharger timer"
        Set Player Variable(Event Player, orisa_supercharger_uptime, 0);
        Chase Player Variable At Rate(Event Player, orisa_supercharger_uptime, 15, 1, None);
        Set Player Variable(Event Player, is_using_supercharger, True);
    }
}

rule ("[orisa/supercharger.opy]: endSupercharger()") {
    event {
        Subroutine;
        endSupercharger;
    }
    actions {
        Set Ultimate Ability Enabled(Event Player, True);
        Stop Chasing Player Variable(Event Player, orisa_supercharger_uptime);
        Destroy Effect((Event Player).orisa_supercharger_entity);
        Set Player Variable(All Players(Team Of(Event Player)), is_supercharged, False);
        Set Player Variable(Event Player, is_using_supercharger, False);
    }
}

rule ("[orisa/supercharger.opy]: Supercharge teammates in supercharger range") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Alive(Event Player) == True;
        ((Event Player).friendly_orisa_player).is_using_supercharger == True;
        Distance Between(Event Player, ((Event Player).friendly_orisa_player).orisa_supercharger_position) <= 25;
        Is In Line of Sight(Event Player, ((Event Player).friendly_orisa_player).orisa_supercharger_position, Barriers Do Not Block LOS) == True;
    }
    actions {
        Set Player Variable(Event Player, is_supercharged, True);
    }
}

rule ("[orisa/supercharger.opy]: De-supercharge teammates outside supercharger range") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_supercharged == True;
        ((Event Player).friendly_orisa_player).is_using_supercharger == True;
        And(Compare(Distance Between(Event Player, ((Event Player).friendly_orisa_player).orisa_supercharger_position), <=, 25), Is In Line of Sight(Event Player, ((Event Player).friendly_orisa_player).orisa_supercharger_position, Barriers Do Not Block LOS)) == False;
    }
    actions {
        Wait(1, Abort When False);
        Set Player Variable(Event Player, is_supercharged, False);
    }
}

rule ("[orisa/supercharger.opy]: De-supercharge teammates when supercharger ends") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).is_using_supercharger == False;
    }
    actions {
        Set Player Variable(All Players(Team Of(Event Player)), is_supercharged, False);
    }
}

rule ("[orisa/supercharger.opy]: De-supercharge teammates when they die") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Dead(Event Player) == True;
        (Event Player).is_supercharged == True;
    }
    actions {
        Set Player Variable(Event Player, is_supercharged, False);
    }
}

rule ("[orisa/supercharger.opy]: Damage boost player when supercharged") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_supercharged == True;
    }
    actions {
        Create Beam Effect(All Players(All Teams), Good Beam, ((Event Player).friendly_orisa_player).orisa_supercharger_position, Position Of(Event Player), Color(Blue), Visible To Position and Radius);
        Set Player Variable(Event Player, orisa_beam_entity, Last Created Entity);
        Create Effect(Event Player, Energy Sound, Color(Green), Position Of(Event Player), 100, Position and Radius);
        Set Player Variable(Event Player, orisa_beam_sound_effect, Last Created Entity);
        Set Damage Dealt(Event Player, 150);
    }
}

rule ("[orisa/supercharger.opy]: Revert damage boost if not supercharged") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_supercharged == False;
    }
    actions {
        Destroy Effect((Event Player).orisa_beam_entity);
        Destroy Effect((Event Player).orisa_beam_sound_effect);
        Set Damage Dealt(Event Player, 100);
    }
}

rule ("[orisa/halt.opy]: Initialize Halt ability") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Player Variable(Event Player, is_using_halt, False);
    }
}

rule ("[orisa/halt.opy]: Trigger Halt ability start") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions {
        Call Subroutine(shootHalt);
        "Make sure player releases right click"
        Wait Until(Not(Is Button Held(Event Player, Button(Secondary Fire))), 999999999999999);
        "Detect halt pull activation on right click"
        Wait Until(Or(Is Button Held(Event Player, Button(Secondary Fire)), Compare((Event Player).halt_position, ==, (Event Player).halt_ending_position)), 999999999999999);
        Call Subroutine(explodeHalt);
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 6);
    }
}

rule ("[orisa/halt.opy]: Shoot Halt Orb") {
    event {
        Subroutine;
        shootHalt;
    }
    actions {
        "Start halt"
        Set Player Variable(Event Player, is_using_halt, True);
        "Halt orb visuals"
        Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).halt_position, 0.6, Visible To Position and Radius);
        Set Player Variable(Event Player, halt_entity1, Last Created Entity);
        Modify Player Variable(Event Player, entity_huds, Append To Array, (Event Player).halt_entity1);
        Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).halt_position, 0.3, Visible To Position and Radius);
        Set Player Variable(Event Player, halt_entity2, Last Created Entity);
        Modify Player Variable(Event Player, entity_huds, Append To Array, (Event Player).halt_entity2);
        "Halt orb sounds"
        Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Lime Green), Event Player, 100);
        "Calculate starting/ending positions"
        Set Player Variable(Event Player, halt_position, Eye Position(Event Player));
        Set Player Variable(Event Player, halt_ending_position, Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(1000, Facing Direction Of(Event Player))), Null, Null, True));
        Set Player Variable(All Players(Opposite Team Of(Team Of(Event Player))), is_snared, False);
        Wait(0.1, Ignore Condition);
        "Start flying halt orb"
        Chase Player Variable At Rate(Event Player, halt_position, (Event Player).halt_ending_position, 25, Destination and Rate);
    }
}

rule ("[orisa/halt.opy]: Explode Halt Orb") {
    event {
        Subroutine;
        explodeHalt;
    }
    actions {
        Stop Chasing Player Variable(Event Player, halt_position);
        Wait(0.45, Ignore Condition);
        Set Player Variable(Players Within Radius((Event Player).halt_position, 5, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), is_snared, True);
        Set Environment Credit Player(Players Within Radius((Event Player).halt_position, 5, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Event Player);
        "Halt orb explosion sounds"
        Play Effect(All Players(All Teams), Explosion Sound, Color(Lime Green), Event Player, 100);
        "Clear visuals"
        Destroy Effect((Event Player).halt_entity1);
        Destroy Effect((Event Player).halt_entity2);
        Modify Player Variable(Event Player, entity_huds, Remove From Array By Value, (Event Player).halt_entity1);
        Modify Player Variable(Event Player, entity_huds, Remove From Array By Value, (Event Player).halt_entity2);
        Set Player Variable(Event Player, is_using_halt, False);
    }
}

rule ("[orirsa.opy]: Slow down snared enemies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_snared == True;
    }
    actions {
        Set Move Speed(Event Player, 33);
        Wait(0.65, Ignore Condition);
        Set Move Speed(Event Player, 100);
    }
}

rule ("[orisa/halt.opy]: Pull halted victims") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_snared == True;
    }
    actions {
        Set Player Variable(Event Player, position, Position Of(Event Player));
        Start Forcing Player Position(Event Player, (Event Player).position, True);
        Chase Player Variable At Rate(Event Player, position, ((Event Player).enemy_orisa_player).halt_position, 20, Destination and Rate);
        Wait Until(Compare((Event Player).position, ==, ((Event Player).enemy_orisa_player).halt_position), 999999999999999);
        Stop Chasing Player Variable(Event Player, position);
        Stop Forcing Player Position(Event Player);
        "Cancel current momentum"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
        Set Player Variable(Event Player, is_snared, False);
    }
}

rule ("[orisa/halt.opy]: Create Halt pull line vfx when in pull range") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        ((Event Player).enemy_orisa_player).is_using_halt == True;
        Distance Between(Event Player, ((Event Player).enemy_orisa_player).halt_position) <= 5;
        Is In Line of Sight(Event Player, ((Event Player).enemy_orisa_player).halt_position, All Barriers Block LOS) == True;
    }
    actions {
        "Halt orb explosion sounds"
        Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Lime Green), Event Player, 100);
        Create Beam Effect(All Players(All Teams), Good Beam, ((Event Player).enemy_orisa_player).halt_position, Event Player, If-Then-Else((Event Player).is_snared, Color(Green), Color(White)), Position Radius and Color);
        Set Player Variable(Event Player, halt_pull_line_entity, Last Created Entity);
        Modify Player Variable(Event Player, entity_huds, Append To Array, (Event Player).halt_pull_line_entity);
    }
}

rule ("[orisa/halt.opy]: Destroy Halt pull line vfx when not in pull range") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        ((Event Player).enemy_orisa_player).is_using_halt == True;
        And(Compare(Distance Between(Event Player, ((Event Player).enemy_orisa_player).halt_position), <=, 5), Is In Line of Sight(Event Player, ((Event Player).enemy_orisa_player).halt_position, All Barriers Block LOS)) == False;
    }
    actions {
        Destroy Effect((Event Player).halt_pull_line_entity);
        Modify Player Variable(Event Player, entity_huds, Remove From Array By Value, (Event Player).halt_pull_line_entity);
    }
}

rule ("[orisa/halt.opy]: Destroy Halt pull line vfx when halt is over") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        ((Event Player).enemy_orisa_player).is_using_halt == False;
    }
    actions {
        Destroy Effect((Event Player).halt_pull_line_entity);
        Modify Player Variable(Event Player, entity_huds, Remove From Array By Value, (Event Player).halt_pull_line_entity);
    }
}

rule ("[orisa/barrier.opy]: Disable OW2 Javelin spin") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
    }
}

rule ("[orisa/barrier.opy]: Trigger Projectile Barrier ability") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Button Held(Event Player, Button(Ability 2)) == True;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Ability 2), 10);
        Call Subroutine(throwBarrier);
        Call Subroutine(destroyBarrier);
        Call Subroutine(deployBarrier);
    }
}

rule ("[orisa/barrier.opy]: throwBarrier()") {
    event {
        Subroutine;
        throwBarrier;
    }
    actions {
        "Initialize barrier projectile"
        Set Player Variable(Event Player, barrier_orientation, Normalize(Multiply(Facing Direction Of(Event Player), Add(Forward, Left))));
        Set Player Variable(Event Player, barrier_proj_v0, Multiply(25, Facing Direction Of(Event Player)));
        Set Player Variable(Event Player, barrier_proj_p0, Eye Position(Event Player));
        Set Player Variable(Event Player, barrier_proj_t, 0);
        Chase Player Variable At Rate(Event Player, barrier_proj_t, 10, 1, Destination and Rate);
        Set Player Variable(Event Player, barrier_proj_velocity, (Event Player).barrier_proj_v0);
        Chase Player Variable At Rate(Event Player, barrier_proj_velocity, Vector(X Component Of((Event Player).barrier_proj_v0), Add(Multiply(-9.8, (Event Player).barrier_proj_t), Y Component Of((Event Player).barrier_proj_v0)), Z Component Of((Event Player).barrier_proj_v0)), 9999, Destination and Rate);
        Set Player Variable(Event Player, barrier_proj_position, (Event Player).barrier_proj_p0);
        Chase Player Variable At Rate(Event Player, barrier_proj_position, Vector(Add(Multiply(X Component Of((Event Player).barrier_proj_v0), (Event Player).barrier_proj_t), X Component Of((Event Player).barrier_proj_p0)), Add(Add(Multiply(-4.9, Raise To Power((Event Player).barrier_proj_t, 2)), Multiply(Y Component Of((Event Player).barrier_proj_v0), (Event Player).barrier_proj_t)), Y Component Of((Event Player).barrier_proj_p0)), Add(Multiply(Z Component Of((Event Player).barrier_proj_v0), (Event Player).barrier_proj_t), Z Component Of((Event Player).barrier_proj_p0))), 9999, Destination and Rate);
        "Draw barrier projectile object"
        Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).barrier_proj_position, 0.1, Position and Radius);
        Set Player Variable(Event Player, barrier_projectile, Last Created Entity);
        "Wait for barrier projectile to land"
        Wait Until(Update Every Frame(Compare(Distance Between((Event Player).barrier_proj_position, Ray Cast Hit Position((Event Player).barrier_proj_position, Add((Event Player).barrier_proj_position, (Event Player).barrier_proj_velocity), Null, Null, False)), <, 0.5)), 10);
        "Freeze barrier projectile"
        Stop Chasing Player Variable(Event Player, barrier_proj_t);
        Stop Chasing Player Variable(Event Player, barrier_proj_velocity);
        Stop Chasing Player Variable(Event Player, barrier_proj_position);
        "Move projectile to where it collided with the ground"
        Set Player Variable(Event Player, barrier_proj_position, Ray Cast Hit Position((Event Player).barrier_proj_position, Add((Event Player).barrier_proj_position, (Event Player).barrier_proj_velocity), Null, Null, False));
        "Destroy projectile"
        Destroy Effect((Event Player).barrier_projectile);
    }
}

rule ("[orisa/barrier.opy]: deployBarrier()") {
    event {
        Subroutine;
        deployBarrier;
    }
    actions {
        "Define barrer by the sphere center position"
        Set Player Variable(Event Player, barrier_position, Subtract((Event Player).barrier_proj_position, Multiply(3.5, (Event Player).barrier_orientation)));
        "Debug barrier center\n createEffect(eventPlayer, Effect.SPHERE, Color.BLACK, eventPlayer.barrier_position, 0.5, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)"
        Call Subroutine(fibonacciSphere);
        "Draw each barrier sample"
        For Global Variable(i, 0, Count Of((Event Player).barrier_entity_positions), 1);
            Set Player Variable(Event Player, barrier_sample_point, Value In Array((Event Player).barrier_entity_positions, Global.i));
            Create Effect(All Players(All Teams), Sphere, If-Then-Else(Compare(Random Real(0, 1), <=, Divide((Event Player).barrier_health, 600)), Team Of(Event Player), Color(White)), Evaluate Once((Event Player).barrier_sample_point), 0.1, Color);
            Modify Player Variable(Event Player, barrier_entities, Append To Array, Last Created Entity);
        End;
        Set Player Variable(Event Player, barrier_active, True);
        Set Player Variable(Event Player, barrier_health, 600);
        Set Player Variable(Event Player, barrier_uptime, 0);
        Chase Player Variable At Rate(Event Player, barrier_uptime, 20, 1, None);
        Call Subroutine(createBarrierHud);
    }
}

rule ("[orisa/barrier.opy]: fibonacciSphere()") {
    event {
        Subroutine;
        fibonacciSphere;
    }
    actions {
        "Evenly distribute N points around a sphere\n Store coodrindate of those points to barrier_entity_positions array\n See https://stackoverflow.com/a/26127012 for algorithm"
        Set Player Variable(Event Player, barrier_entity_positions, Empty Array);
        For Global Variable(i, 0, 200, 1);
            Set Player Variable(Event Player, barrier_sample_y, Subtract(1, Multiply(Divide(Global.i, 199), 2)));
            "Do not draw bottom half of sphere"
            If(Compare((Event Player).barrier_sample_y, <, -0.2));
                Break;
            End;
            Set Player Variable(Event Player, barrier_sample_radius, Square Root(Subtract(1, Multiply((Event Player).barrier_sample_y, (Event Player).barrier_sample_y))));
            Set Player Variable(Event Player, barrier_sample_theta, Multiply(Global.PHI, Global.i));
            Set Player Variable(Event Player, barrier_sample_x, Multiply(Cosine From Radians((Event Player).barrier_sample_theta), (Event Player).barrier_sample_radius));
            Set Player Variable(Event Player, barrier_sample_z, Multiply(Sine From Radians((Event Player).barrier_sample_theta), (Event Player).barrier_sample_radius));
            Set Player Variable(Event Player, barrier_sample_point, Vector((Event Player).barrier_sample_x, (Event Player).barrier_sample_y, (Event Player).barrier_sample_z));
            Skip If(Compare(Angle Between Vectors((Event Player).barrier_sample_point, (Event Player).barrier_orientation), >, 90), 1);
            Modify Player Variable(Event Player, barrier_entity_positions, Append To Array, Add(Multiply(3.5, (Event Player).barrier_sample_point), (Event Player).barrier_position));
            //__label_continue_2__:
        End;
    }
}

rule ("[orisa/barrier.opy]: destroyBarrier()") {
    event {
        Subroutine;
        destroyBarrier;
    }
    actions {
        For Global Variable(i, 0, Count Of((Event Player).barrier_entities), 1);
            Destroy Effect(Value In Array((Event Player).barrier_entities, Global.i));
        End;
        Set Player Variable(Event Player, barrier_entities, Empty Array);
        Set Player Variable(Event Player, barrier_entity_positions, Empty Array);
        Set Player Variable(Event Player, barrier_active, False);
        Call Subroutine(destroyBarrierHud);
    }
}

rule ("[orisa/barrier.opy]: destroy barrier on reset") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).barrier_active == True;
        (Event Player).call_reset == True;
    }
    actions {
        Call Subroutine(destroyBarrier);
    }
}

rule ("[orisa/barrier.opy]: Destroy barrier on barrier timeout") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).barrier_uptime >= 20;
    }
    actions {
        Stop Chasing Player Variable(Event Player, barrier_uptime);
        Call Subroutine(destroyBarrier);
    }
}

rule ("[orisa/barrier.opy]: Destroy barrier when barrier hp runs out") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).barrier_health <= 0;
    }
    actions {
        Stop Chasing Player Variable(Event Player, barrier_uptime);
        Call Subroutine(destroyBarrier);
    }
}

rule ("[orisa/barrier.opy]: Take no damage when behind barrier") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        ((Victim).friendly_orisa_player).barrier_active == True;
        Multiply(Distance Between(Eye Position(Attacker), ((Victim).friendly_orisa_player).barrier_position), Sine From Degrees(Angle Between Vectors(Facing Direction Of(Attacker), Direction Towards(Eye Position(Attacker), ((Victim).friendly_orisa_player).barrier_position)))) <= 3.5;
    }
    actions {
        Set Player Variable(Event Player, lsi_o, Eye Position(Attacker));
        Set Player Variable(Event Player, lsi_u, Direction Towards(Attacker, Victim));
        Set Player Variable(Event Player, lsi_c, ((Victim).friendly_orisa_player).barrier_position);
        Set Player Variable(Event Player, lsi_r, 3.5);
        Call Subroutine(findLineSphereIntersection);
        Set Player Variable(Event Player, orisa_barrier_hit_positions, Filtered Array((Event Player).lsi_x, And(And(Compare(Distance Between(((Victim).friendly_orisa_player).barrier_position, Current Array Element), <=, 3.5), Compare(Angle Between Vectors(Up, Direction Towards(((Victim).friendly_orisa_player).barrier_position, Current Array Element)), <=, 90)), Compare(Angle Between Vectors(((Victim).friendly_orisa_player).barrier_orientation, Direction Towards(((Victim).friendly_orisa_player).barrier_position, Current Array Element)), <=, 90))));
        For Global Variable(i, 0, Count Of((Event Player).orisa_barrier_hit_positions), 1);
            "barrier hit is between the attacker and the victim"
            If(Compare(Distance Between(Eye Position(Attacker), Value In Array((Event Player).orisa_barrier_hit_positions, Global.i)), <, Distance Between(Eye Position(Attacker), Eye Position(Victim))));
                Heal(Victim, Null, Event Damage);
                Modify Player Variable((Victim).friendly_orisa_player, barrier_health, Subtract, Event Damage);
                Abort;
            End;
        End;
    }
}

rule ("[orisa/barrier.opy]: Receive no healing when behind barrier") {
    event {
        Player Received Healing;
        All;
        All;
    }
    conditions {
        ((Healee).enemy_orisa_player).barrier_active == True;
        Multiply(Distance Between(Eye Position(Healer), ((Healee).enemy_orisa_player).barrier_position), Sine From Degrees(Angle Between Vectors(Direction Towards(Healer, Healee), Direction Towards(Eye Position(Healer), ((Healee).enemy_orisa_player).barrier_position)))) <= 3.5;
    }
    actions {
        Set Player Variable(Event Player, lsi_o, Eye Position(Healer));
        Set Player Variable(Event Player, lsi_u, Direction Towards(Healer, Healee));
        Set Player Variable(Event Player, lsi_c, ((Healee).enemy_orisa_player).barrier_position);
        Set Player Variable(Event Player, lsi_r, 3.5);
        Call Subroutine(findLineSphereIntersection);
        Set Player Variable(Event Player, orisa_barrier_hit_positions, Filtered Array((Event Player).lsi_x, And(And(Compare(Distance Between(((Healee).enemy_orisa_player).barrier_position, Current Array Element), <=, 3.5), Compare(Angle Between Vectors(Up, Direction Towards(((Healee).enemy_orisa_player).barrier_position, Current Array Element)), <=, 90)), Compare(Angle Between Vectors(((Healee).enemy_orisa_player).barrier_orientation, Direction Towards(((Healee).enemy_orisa_player).barrier_position, Current Array Element)), <=, 90))));
        For Global Variable(i, 0, Count Of((Event Player).orisa_barrier_hit_positions), 1);
            "barrier hit is between the healer and the healee"
            If(Compare(Distance Between(Eye Position(Healer), Value In Array((Event Player).orisa_barrier_hit_positions, Global.i)), <, Distance Between(Eye Position(Healer), Eye Position(Healee))));
                Damage(Healee, Null, Event Healing);
                Modify Player Variable((Healee).enemy_orisa_player, barrier_health, Subtract, Event Healing);
                Abort;
            End;
        End;
    }
}

rule ("[orisa/barrier.opy]: createBarrierHud()") {
    event {
        Subroutine;
        createBarrierHud;
    }
    actions {
        Create Progress Bar HUD Text(Event Player, Divide(Multiply(100, (Event Player).barrier_health), 600), Custom String("{0}", Round To Integer((Event Player).barrier_health, Up), Null, Null), Top, 999999999999999, Color(Sky Blue), Color(White), Values, Default Visibility);
        Set Player Variable(Event Player, barrier_health_hud, Last Text ID);
    }
}

rule ("[orisa/barrier.opy]: destroyBarrierHud()") {
    event {
        Subroutine;
        destroyBarrierHud;
    }
    actions {
        Destroy Progress Bar HUD Text((Event Player).barrier_health_hud);
    }
}

rule ("[orisa/gun.opy]: Initialize OW1 Orisa clip size") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        Call Subroutine(resetFusionDriver);
        Call Subroutine(createOrisaAmmoHud);
        Set Player Variable(Event Player, is_orisa_reloading, False);
    }
}

rule ("[orisa/gun.opy]: Remove ammo hud") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).call_reset == True;
    }
    actions {
        Call Subroutine(destroyOrisaAmmoHud);
    }
}

rule ("[orisa/gun.opy]: Decrease ammo when shooting gun") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
    }
    actions {
        Modify Player Variable(Event Player, orisa_ammo, Subtract, 1);
        Call Subroutine(refreshAmmo);
        Set Primary Fire Enabled(Event Player, False);
        Wait(0.083333333333333, Ignore Condition);
        Set Primary Fire Enabled(Event Player, True);
    }
}

rule ("[orisa/gun.opy]: Reload on key press") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Reload)) == True;
    }
    actions {
        Call Subroutine(reloadFusionDriver);
    }
}

rule ("[orisa/gun.opy]: Reload when out of ammo") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).orisa_ammo <= 0;
    }
    actions {
        Call Subroutine(reloadFusionDriver);
    }
}

rule ("[orisa/gun.opy]: resetFusionDriver()") {
    event {
        Subroutine;
        resetFusionDriver;
    }
    actions {
        Set Max Ammo(Event Player, 0, 151);
        Set Player Variable(Event Player, orisa_ammo, 150);
        Call Subroutine(refreshAmmo);
    }
}

rule ("[orisa/gun.opy]: reloadFusionDriver()") {
    event {
        Subroutine;
        reloadFusionDriver;
    }
    actions {
        Abort If(Compare((Event Player).orisa_ammo, >=, 150));
        "Play reload animation"
        Set Ammo(Event Player, 0, 0);
        Set Player Variable(Event Player, is_orisa_reloading, True);
        Wait(2.5, Ignore Condition);
        Set Player Variable(Event Player, is_orisa_reloading, False);
        Call Subroutine(resetFusionDriver);
    }
}

rule ("[orisa/gun.opy]: refreshAmmo()") {
    event {
        Subroutine;
        refreshAmmo;
    }
    actions {
        Set Ammo(Event Player, 0, Add((Event Player).orisa_ammo, 1));
    }
}

rule ("[orisa/gun.opy]: createOrisaAmmoHud()") {
    event {
        Subroutine;
        createOrisaAmmoHud;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).orisa_ammo, Up), Null, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(3.3, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.5, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, orisa_ammo_hud, Last Text ID);
    }
}

rule ("[orisa/gun.opy]: destroyOrisaAmmoHud()") {
    event {
        Subroutine;
        destroyOrisaAmmoHud;
    }
    actions {
        Destroy In-World Text((Event Player).orisa_ammo_hud);
    }
}

rule ("[orisa/gun.opy]: Slow down Orisa when shooting") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Primary Fire)) == True;
        (Event Player).is_orisa_reloading == False;
    }
    actions {
        Set Move Speed(Event Player, 70);
        Wait Until(Or(Not(Is Button Held(Event Player, Button(Primary Fire))), (Event Player).is_orisa_reloading), 999999999999999);
        Set Move Speed(Event Player, 100);
    }
}

rule ("[orisa/fortify.opy]: Remove overhealth during fortify") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Damage(Event Player, Null, 250);
    }
}

rule ("[orisa/orisa.opy]: Initialize Orisa") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).call_init == True;
    }
    actions {
        "Below variables are also declared and initialized in reset_hero.opy"
        Set Player Variable(All Players(Team Of(Event Player)), friendly_orisa_player, Event Player);
        Set Player Variable(All Players(Opposite Team Of(Team Of(Event Player))), enemy_orisa_player, Event Player);
    }
}

rule ("[ramattra.opy]: Initialize Ramattra") {
    event {
        Ongoing - Each Player;
        All;
        Ramattra;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 400);
        Set Player Variable(Event Player, hp_armor, 0);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
        Set Knockback Received(Event Player, 142.85714285714286);
    }
}

rule ("[reaper.opy]: Deal OW1 Reaper primary fire damage") {
    event {
        Player Dealt Damage;
        All;
        Reaper;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.111111111111111), Event Damage));
    }
}

rule ("[reinhardt/hp.opy]: Initialize Reinhardt hp") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 300);
        Set Player Variable(Event Player, hp_armor, 200);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
    }
}

rule ("[reinhardt/firestrike.opy]: Force single firestrike") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 1);
        "Every time rein uses firestrike, reset the resource to 0"
        Set Ability Charge(Event Player, Button(Ability 2), 0);
        Wait(6, Ignore Condition);
        Set Ability Charge(Event Player, Button(Ability 2), 2);
    }
}

rule ("[reinhardt/charge.opy]: Set default charge cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 10);
    }
}

rule ("[reinhardt/charge.opy]: Increase charge damage") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ability 1);
        "Checks for pin vs boop damage (+ 1 because apparently 50.0 > 50 == true for whatever reason)"
        Event Damage > 51;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.333333333333333), Event Damage));
    }
}

rule ("[reinhardt/charge.opy]: Reduce charge radius") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Start Forcing Throttle(Event Player, 0, 0.666666666666666, 0, 0.666666666666666, 0, 0.666666666666666);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Stop Forcing Throttle(Event Player);
    }
}

rule ("[reinhardt/shatter.opy]: OW1 one shot earthshatter") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ultimate);
        Event Damage > 85;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.470588235294117), Event Damage));
    }
}

rule ("[roadhog.opy]: Initialize Roadhog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 600);
        Set Player Variable(Event Player, hp_armor, 0);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
        Set Ammo(Event Player, 0, 5);
        Set Max Ammo(Event Player, 0, 5);
        Set Damage Dealt(Event Player, 110);
        Set Knockback Received(Event Player, 142.85714285714286);
    }
}

rule ("[roadhog.opy]: Set default hook cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, time_hook_was_active, 0);
        Chase Player Variable At Rate(Event Player, time_hook_was_active, 3, 1, None);
        Wait Until(Not(Is Using Ability 1(Event Player)), 99999);
        Set Ability Cooldown(Event Player, Button(Ability 1), Subtract(8, (Event Player).time_hook_was_active));
    }
}

rule ("[roadhog.opy]: Disable all abilities during ult") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Melee Enabled(Event Player, False);
        Set Ability 1 Enabled(Event Player, False);
        Set Ability 2 Enabled(Event Player, False);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Melee Enabled(Event Player, True);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability 2 Enabled(Event Player, True);
    }
}

rule ("[roadhog.opy]: Force autofire during ult") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Is Button Held(Event Player, Button(Primary Fire)) == False;
    }
    actions {
        Start Holding Button(Event Player, Button(Primary Fire));
    }
}

rule ("[roadhog.opy]: Stop autofire when not in ult") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}

rule ("[roadhog.opy]: Cancel ult when stunned") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Or(Or(Or(Or(Has Status(Event Player, Hacked), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)), Has Status(Event Player, Asleep)), Has Status(Event Player, Stunned)) == True;
    }
    actions {
        If(Has Status(Event Player, Hacked));
        Else If(Has Status(Event Player, Frozen));
            Wait Until(Not(Has Status(Event Player, Frozen)), 999999999999999);
        Else If(Has Status(Event Player, Knocked Down));
            Wait Until(Not(Has Status(Event Player, Knocked Down)), 999999999999999);
        Else If(Has Status(Event Player, Asleep));
            Wait Until(Not(Has Status(Event Player, Asleep)), 999999999999999);
        Else If(Has Status(Event Player, Stunned));
            Wait Until(Not(Has Status(Event Player, Stunned)), 999999999999999);
        End;
        If(Is Using Ultimate(Event Player));
            Call Subroutine(respawnSameState);
    }
}

rule ("[roadhog.opy]: Move hooked enemies closer") {
    event {
        Player Dealt Damage;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        If(Compare(Distance Between(Victim, Attacker), <=, 4.5));
            Teleport(Victim, Ray Cast Hit Position(Position Of(Victim), Add(Position Of(Victim), Direction Towards(Victim, Attacker)), Null, Null, False));
    }
}

rule ("[roadhog.opy]: Reduce ultimate duration") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Wait(6, Ignore Condition);
        "Check if the ultimate was not cancelled before"
        If(Is Using Ultimate(Event Player));
            Call Subroutine(respawnSameState);
    }
}

rule ("[sigma.opy]: Initialize Sigma") {
    event {
        Ongoing - Each Player;
        All;
        Sigma;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 300);
        Set Player Variable(Event Player, hp_armor, 0);
        Set Player Variable(Event Player, hp_shields, 100);
        Call Subroutine(applyCustomHealth);
        Set Knockback Received(Event Player, 142.85714285714286);
    }
}

rule ("[sigma.opy]: Change accretion damage") {
    event {
        Player Dealt Damage;
        All;
        Sigma;
    }
    conditions {
        Event Ability == Button(Ability 2);
        "Checks for direct hit vs splash damage"
        Event Damage > 40;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.375), Event Damage));
    }
}

rule ("[soldier.opy]: Initialize Soldier 76") {
    event {
        Ongoing - Each Player;
        All;
        Soldier: 76;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Set Healing Dealt(Event Player, 87.5);
    }
}

rule ("[soldier.opy]: Deal OW1 soldier primary fire damage") {
    event {
        Player Dealt Damage;
        All;
        Soldier: 76;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.052631578947368), Event Damage));
    }
}

rule ("[sombra.opy]: Initialize Sombra") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Set Player Variable(All Players(Team Of(Event Player)), friendly_sombra_player, Event Player);
        Set Player Variable(All Players(Opposite Team Of(Team Of(Event Player))), enemy_sombra_player, Event Player);
    }
}

rule ("[sombra.opy]: Cancel invis if hack activated") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Press Button(Event Player, Button(Ability 1));
    }
}

rule ("[sombra.opy]: OW1 hack duration on enemies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Has Status(Event Player, Hacked) == True;
    }
    actions {
        Set Status(Event Player, Null, Hacked, 5);
    }
}

rule ("[sombra.opy]: No damage with EMP") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Ultimate Charge Percent(Event Player) >= 100;
    }
    actions {
        Wait Until(Is Button Held(Event Player, Button(Ultimate)), 999999999999999);
        Wait Until(Compare(Ultimate Charge Percent(Event Player), <=, 0), 999999999999999);
        Set Damage Dealt(Event Player, 0);
        Wait Until(Is Using Ultimate(Event Player), 999999999999999);
        Set Damage Dealt(Event Player, 100);
    }
}

rule ("[sombra.opy]: Deal OW1 machine pistol damage") {
    event {
        Player Dealt Damage;
        All;
        Sombra;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.066666666666666), Event Damage));
    }
}

rule ("[sombra.opy]: Remove hack bonus damage") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Has Status(Event Player, Hacked) == True;
    }
    actions {
        Start Damage Modification(Event Player, (Event Player).enemy_sombra_player, 80, None);
        Set Player Variable(Event Player, hack_damage_modifier, Last Damage Modification ID);
        Wait Until(Not(Has Status(Event Player, Hacked)), 999999999999999);
        Stop Damage Modification((Event Player).hack_damage_modifier);
    }
}

rule ("[sombra.opy]: Increase stealth movement speed") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Move Speed(Event Player, 103.125);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999999999999);
        Set Move Speed(Event Player, 100);
    }
}

rule ("[sombra.opy]: Set default hack cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Secondary Fire)) >= 4;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 8);
    }
}

rule ("[symmetra.opy]: Initialize Symmetra") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Set Ammo(Event Player, 0, 70);
        Set Max Ammo(Event Player, 0, 70);
    }
}

rule ("[symmetra.opy]: Set OW1 Symmetra Photo Projector projectile speed") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Projectile Speed(Event Player, 50);
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999999999999);
        Set Projectile Speed(Event Player, 100);
    }
}

rule ("[torbjorn.opy]: Initialize Torbjorn") {
    event {
        Ongoing - Each Player;
        All;
        Torbjörn;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 200);
        Set Player Variable(Event Player, hp_armor, 50);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
    }
}

rule ("[torbjorn.opy]: Correct overload hp") {
    event {
        Ongoing - Each Player;
        All;
        Torbjörn;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Damage(Event Player, Null, 11.111111111111114);
    }
}

rule ("[tracer.opy]: Deal OW1 tracer primary fire damage") {
    event {
        Player Dealt Damage;
        All;
        Tracer;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.090909090909090), Event Damage));
    }
}

rule ("[widowmaker.opy]: Initialize Widowmaker") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 175);
        Set Player Variable(Event Player, hp_armor, 0);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
    }
}

rule ("[widowmaker.opy]: Revert sniper damage falloff") {
    event {
        Player Dealt Damage;
        All;
        Widowmaker;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Firing Primary(Event Player) == True;
        Event Ability == Button(Primary Fire);
    }
    actions {
        Set Player Variable(Event Player, scoped_shot_distance, Distance Between(Eye Position(Attacker), Victim));
        Set Player Variable(Event Player, ow2_scoped_damage_falloff_scalar, Add(Multiply(Divide(Subtract((Event Player).scoped_shot_distance, 40), 20), 0.5), Subtract(1, Divide(Subtract((Event Player).scoped_shot_distance, 40), 20))));
        "Cap min/max scalar\n Max damage scalar"
        If(Compare((Event Player).ow2_scoped_damage_falloff_scalar, >, 1));
            Set Player Variable(Event Player, ow2_scoped_damage_falloff_scalar, 1);
        "Min damage scalar"
        Else If(Compare((Event Player).ow2_scoped_damage_falloff_scalar, <, 0.5));
            Set Player Variable(Event Player, ow2_scoped_damage_falloff_scalar, 0.5);
        End;
        Set Player Variable(Event Player, scoped_damage_base, Divide(Event Damage, (Event Player).ow2_scoped_damage_falloff_scalar));
        Set Player Variable(Event Player, ow1_scoped_damage_falloff_scalar, Add(Multiply(Divide(Subtract((Event Player).scoped_shot_distance, 70), 30), 0.3), Subtract(1, Divide(Subtract((Event Player).scoped_shot_distance, 70), 30))));
        "Cap min/max scalar\n Max damage scalar"
        If(Compare((Event Player).ow1_scoped_damage_falloff_scalar, >, 1));
            Set Player Variable(Event Player, ow1_scoped_damage_falloff_scalar, 1);
        "Min damage scalar"
        Else If(Compare((Event Player).ow1_scoped_damage_falloff_scalar, <, 0.3));
            Set Player Variable(Event Player, ow1_scoped_damage_falloff_scalar, 0.3);
        End;
        Set Player Variable(Event Player, expected_scoped_damage, Multiply((Event Player).scoped_damage_base, (Event Player).ow1_scoped_damage_falloff_scalar));
        Damage(Victim, Attacker, Subtract((Event Player).expected_scoped_damage, Event Damage));
    }
}

rule ("[winston.opy]: Initialize Winston") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 350);
        Set Player Variable(Event Player, hp_armor, 150);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
        Set Secondary Fire Enabled(Event Player, False);
        Set Knockback Received(Event Player, 142.85714285714286);
    }
}

rule ("[winston.opy]: Set default leap cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Ability 1), 6);
    }
}

rule ("[winston.opy]: Set leap after ultimate") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
    }
}

rule ("[wreckingball.opy]: Initialize Wrecking Ball") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 500);
        Set Player Variable(Event Player, hp_armor, 100);
        Set Player Variable(Event Player, hp_shields, 0);
        Call Subroutine(applyCustomHealth);
        Set Knockback Received(Event Player, 142.85714285714286);
    }
}

rule ("[zarya.opy]: Initialize Zarya") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, hp_health, 200);
        Set Player Variable(Event Player, hp_armor, 0);
        Set Player Variable(Event Player, hp_shields, 200);
        Call Subroutine(applyCustomHealth);
        Set Player Variable(Event Player, self_bubble_cooldown, 0);
        Set Player Variable(Event Player, ally_bubble_cooldown, 0);
        Set Knockback Received(Event Player, 142.85714285714286);
    }
}

rule ("[zarya.opy]: showSelfBubbleCD()") {
    event {
        Subroutine;
        showSelfBubbleCD;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).self_bubble_cooldown, Up), Null, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(1.99, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.64, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, self_bubble_cd_text, Last Text ID);
        Modify Player Variable(Event Player, text_huds, Append To Array, (Event Player).self_bubble_cd_text);
    }
}

rule ("[zarya.opy]: hideSelfBubbleCD()") {
    event {
        Subroutine;
        hideSelfBubbleCD;
    }
    actions {
        Destroy In-World Text((Event Player).self_bubble_cd_text);
        Modify Player Variable(Event Player, text_huds, Remove From Array By Value, (Event Player).self_bubble_cd_text);
    }
}

rule ("[zarya.opy]: showAllyBubbleCD()") {
    event {
        Subroutine;
        showAllyBubbleCD;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).ally_bubble_cooldown, Up), Null, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(2.3, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.66, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, ally_bubble_cd_text, Last Text ID);
        Modify Player Variable(Event Player, text_huds, Append To Array, (Event Player).ally_bubble_cd_text);
    }
}

rule ("[zarya.opy]: hideAllyBubbleCD()") {
    event {
        Subroutine;
        hideAllyBubbleCD;
    }
    actions {
        Destroy In-World Text((Event Player).ally_bubble_cd_text);
        Modify Player Variable(Event Player, text_huds, Remove From Array By Value, (Event Player).ally_bubble_cd_text);
    }
}

rule ("[zarya.opy]: OW1 zarya self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Ability Charge(Event Player, Button(Ability 1), 2);
        Set Ability 1 Enabled(Event Player, False);
        "2 second bubble duration"
        Wait(2, Ignore Condition);
        Set Player Variable(Event Player, self_bubble_cooldown, 10);
        Chase Player Variable At Rate(Event Player, self_bubble_cooldown, 0, 1, None);
    }
}

rule ("[zarya.opy]: OW1 zarya ally bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Ability Charge(Event Player, Button(Ability 2), 2);
        Set Ability 2 Enabled(Event Player, False);
        "2 second bubble duration"
        Wait(2, Ignore Condition);
        Set Player Variable(Event Player, ally_bubble_cooldown, 8);
        Chase Player Variable At Rate(Event Player, ally_bubble_cooldown, 0, 1, None);
    }
}

rule ("[zarya.opy]: Disable self bubble if on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).self_bubble_cooldown > 0;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
    }
}

rule ("[zarya.opy]: Disable ally bubble if on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).ally_bubble_cooldown > 0;
    }
    actions {
        Set Ability 2 Enabled(Event Player, False);
    }
}

rule ("[zarya.opy]: Enable self bubble if not on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).self_bubble_cooldown <= 0;
    }
    actions {
        Set Ability 1 Enabled(Event Player, True);
    }
}

rule ("[zarya.opy]: Enable ally bubble if not on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).ally_bubble_cooldown <= 0;
    }
    actions {
        Set Ability 2 Enabled(Event Player, True);
    }
}

rule ("[zarya.opy]: Draw self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).self_bubble_cooldown > 0;
    }
    actions {
        Call Subroutine(showSelfBubbleCD);
    }
}

rule ("[zarya.opy]: Erase self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).self_bubble_cooldown <= 0;
    }
    actions {
        Call Subroutine(hideSelfBubbleCD);
    }
}

rule ("[zarya.opy]: Draw self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).ally_bubble_cooldown > 0;
    }
    actions {
        Call Subroutine(showAllyBubbleCD);
    }
}

rule ("[zarya.opy]: Erase self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).ally_bubble_cooldown <= 0;
    }
    actions {
        Call Subroutine(hideAllyBubbleCD);
    }
}

rule ("[zenyatta.opy]: Initialize Zenyatta") {
    event {
        Ongoing - Each Player;
        All;
        Zenyatta;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).call_init == True;
    }
    actions {
        Set Ammo(Event Player, 0, 20);
        Set Max Ammo(Event Player, 0, 20);
        Set Knockback Dealt(Event Player, 5);
    }
}

rule ("[zenyatta.opy]: Allow self healing during Transcendence") {
    event {
        Ongoing - Each Player;
        All;
        Zenyatta;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999999999999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[debug.opy]: global debug (Top Left)") {
    event {
        Ongoing - Global;
    }
    conditions {
        Global.debug == True;
    }
    actions {
        Create HUD Text(All Players(All Teams), Custom String("Global", Null, Null, Null), Null, Null, Left, 0, Color(White), Null, Null, Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Custom String("Server Load: {0}%", Server Load, Null, Null), Null, Left, 1, Null, Color(White), Null, Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Custom String("Server Load Average: {0}%", Server Load Average, Null, Null), Null, Left, 1, Null, Color(White), Null, Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Custom String("Server Load Peak: {0}%", Server Load Peak, Null, Null), Null, Left, 1, Null, Color(White), Null, Visible To and String, Default Visibility);
    }
}

rule ("[debug.opy]: player debug (Top Right)") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.debug == True;
    }
    actions {
        Create HUD Text(Event Player, Custom String("Event Player", Null, Null, Null), Null, Null, Right, 0, Color(White), Null, Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getAltitude() = {0}", Altitude Of(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("hasStatusEffect(Status.HACKED) = {0}", Has Status(Event Player, Hacked), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("hasStatusEffect(Status.STUNNED) = {0}", Has Status(Event Player, Stunned), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getStatistic(Stat.HERO_DAMAGE_DEALT) = {0}", Player Stat(Event Player, Hero Damage Dealt), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("len(allowed_heroes) = {0}", Count Of((Event Player).allowed_heroes), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("len(getAllowedHeroes()) = {0}", Count Of(Allowed Heroes(Event Player)), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isUsingUltimate() = {0}", Is Using Ultimate(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getUltCharge() = {0}", Ultimate Charge Percent(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getUltCharge() >= 100 = {0}", Compare(Ultimate Charge Percent(Event Player), >=, 100), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isFiringPrimaryFire() = {0}", Is Firing Primary(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isFiringSecondaryFire() = {0}", Is Firing Secondary(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isUsingAbility1() = {0}", Is Using Ability 1(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isUsingAbility2() = {0}", Is Using Ability 2(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getSpeed() = {0}", Speed Of(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("ult_cost[hero_id] = {0}", Value In Array(Global.ult_cost, (Event Player).hero_id), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("ult_percent_compensated = {0}", (Event Player).ult_percent_compensated, Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("call_reset = {0}", (Event Player).call_reset, Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("call_init = {0}", (Event Player).call_init, Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getMaxHealth() = {0}", Max Health(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("orisa_ammo = {0}", (Event Player).orisa_ammo, Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isReloading() = {0}", Is Reloading(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getAmmo(0) = {0}", Ammo(Event Player, 0), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isHoldingButton(Button.PRIMARY_FIRE) = {0}", Is Button Held(Event Player, Button(Primary Fire)), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("self_healing_percent = {0}", (Event Player).self_healing_percent, Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getPosition() = {0}", Position Of(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("role = {0}", (Event Player).role, Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isInAlternateForm() = {0}", Is In Alternate Form(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("Ability 1 Cooldown = {0}", Ability Cooldown(Event Player, Button(Ability 1)), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("is_using_guardian_angel = {0}", (Event Player).is_using_guardian_angel, Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("is_slingshotting = {0}", (Event Player).is_slingshotting, Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
    }
}

rule ("[debug.opy]: print to console on interact") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.debug == True;
        Is Button Held(Event Player, Button(Interact)) == True;
    }
    actions {
        For Global Variable(i, 0, Count Of((Event Player).allowed_heroes), 1);
            Log To Inspector(Custom String("eventPlayer.allowed_heroes[{0}] = {1}", Global.i, Value In Array((Event Player).allowed_heroes, Global.i), Null));
        End;
    }
}

rule ("[debug.opy]: Debug damage instance") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Global.debug == True;
    }
    actions {
        Log To Inspector(Custom String("hero={0}, ability={1}, amount={2}", Hero Of(Event Player), Event Ability, Event Damage));
    }
}

rule ("[debug.opy]: Debug healing instance") {
    event {
        Player Dealt Healing;
        All;
        All;
    }
    conditions {
        Global.debug == True;
    }
    actions {
        Log To Inspector(Custom String("hero={0}, ability={1}, amount={2}", Hero Of(Event Player), Event Ability, Event Healing));
    }
}

