settings
{
	main
	{
		Description: "Overwatch 1 Emulator v0.7.2 (main build)\r\n\r\necksdee#11729's attempt to accurately recreate \r\nthe last version of Overwatch 1 using workshop.\r\n\r\nMain build: KHTG0\r\nStaging build: ESMXJ\r\n\r\nDev Team:\r\necksdee#11729\r\nSnappy#11809\r\nKingDonMike#2694\r\nthenova#21104\r\npretz#11551\r\n\r\nGamemode:\r\nworkshop.codes/ow1-emulator\r\n\r\nDiscord:\r\ndsc.gg/ow1\r\ndiscord.gg/GMVqwYXbWB\r\n\r\nSource code:\r\ngithub.com/MaxwellJung/ow1_emulator"
		Mode Name: "Overwatch 1 Emulator"
	}
	lobby
	{
		Map Rotation: After A Game
		Match Voice Chat: Enabled
		Max Spectators: 12
		Max Team 1 Players: 6
		Max Team 2 Players: 6
		Return To Lobby: Never
		Team Balancing: After A Game
	}
	modes
	{
		Assault
		{
			enabled maps
			{
				Hanamura
				Horizon Lunar Colony
				Paris
				Temple of Anubis
				Volskaya Industries
			}
		}
		Control
		{
			enabled maps
			{
				Busan 972777519512068154
				Ilios 972777519512068154
				Lijiang Tower 972777519512068153
				Nepal 972777519512068154
				Oasis 972777519512068292
			}
		}
		Escort
		{
			enabled maps
			{
				Dorado 972777519512068153
				Havana 972777519512068154
				Rialto
				Route 66 972777519512068154
				Watchpoint: Gibraltar 972777519512068292
			}
		}
		Hybrid
		{
			enabled maps
			{
				Blizzard World 972777519512068154
				Eichenwalde 972777519512068154
				Hollywood 972777519512068154
				King's Row 972777519512068153
				Numbani
			}
		}
		Practice Range
		{
			enabled maps
			{
			}
		}
		General
		{
			Hero Limit: 1 Per Team
			Limit Roles: Off
			Tank Role Passive Health Bonus: Always Enabled
			Competitive Rules: On
		}
	}
	heroes
	{
		General
		{
			Ana
			{
				Ultimate Generation Nano Boost: 100%
			}
			Ashe
			{
				Ultimate Generation B.O.B.: 100%
			}
			Baptiste
			{
				Ultimate Generation Amplification Matrix: 100%
			}
			Bastion
			{
				Ultimate Generation Configuration: Artillery: 100%
			}
			Brigitte
			{
				Health: 100%
				Ultimate Generation Rally: 96.53571428571429%
			}
			Cassidy
			{
				Ultimate Generation Deadeye: 110.11904761904762%
			}
			Doomfist
			{
				Ammunition Regeneration Time Scalar: 162%
			}
			D.Va
			{
				Defense Matrix Maximum Time: 67%
				Ultimate Generation Self-Destruct: 100%
			}
			Echo
			{
				Ultimate Generation Duplicate: 75.02218278615794%
			}
			Genji
			{
				Ultimate Generation Dragonblade: 100%
			}
			Hanzo
			{
				Ultimate Generation Dragonstrike: 100%
			}
			Junkrat
			{
				Ultimate Generation RIP-Tire: 100%
			}
			Lúcio
			{
				Ultimate Generation Sound Barrier: 82.31292517006803%
			}
			Mei
			{
				Ultimate Generation Blizzard: 108.69565217391305%
			}
			Mercy
			{
				Ultimate Generation Valkyrie: 100%
				Sympathetic Recovery: Off
			}
			Moira
			{
				Ultimate Generation Coalescence: 95%
			}
			Pharah
			{
				Ultimate Generation Barrage: 95.23809523809524%
			}
			Ramattra
			{
				Health: 100%
			}
			Reaper
			{
				Ultimate Generation Death Blossom: 91.9047619047619%
			}
			Reinhardt
			{
				Barrier Field Recharge Rate: 139%
				Health: 114.28571428571429%
				Ultimate Generation Earthshatter: 107.14285714285714%
			}
			Roadhog
			{
				Ultimate Generation Whole Hog: 108.03571428571429%
			}
			Sigma
			{
				Experimental Barrier Recharge Rate: 80%
				Health: 100%
				Ultimate Generation Gravitic Flux: 107.14285714285714%
			}
			Soldier: 76
			{
				Ultimate Generation Tactical Visor: 110%
			}
			Sombra
			{
				Ultimate Generation EMP: 115%
			}
			Symmetra
			{
				Ultimate Generation Photon Barrier: 100%
			}
			Torbjörn
			{
				Health: 111.11111111111111%
				Ultimate Generation Molten Core: 100%
			}
			Tracer
			{
				Ultimate Generation Pulse Bomb: 100%
			}
			Widowmaker
			{
				Ultimate Generation Infra-Sight: 100%
			}
			Winston
			{
				Health: 107.6923076923077%
				Ultimate Generation Primal Rage: 120.12987012987013%
			}
			Wrecking Ball
			{
				Ultimate Generation Minefield: 108.76623376623377%
				Piledriver Cooldown Time: 125%
			}
			Zarya
			{
				Health: 100%
			}
			Zenyatta
			{
				Ultimate Generation Transcendence: 100%
			}
			enabled heroes
			{
				Tracer
			}
		}
	}
}
variables {
    global:
        0: i
        1: ow1_tank_heroes
        2: ow1_damage_heroes
        3: ow1_support_heroes
        4: ow2_tank_heroes
        5: ow2_damage_heroes
        6: ow2_support_heroes
        7: tank_heroes
        8: damage_heroes
        9: support_heroes
        10: all_heroes
        11: hero_select_time
        12: max_tank_count
        13: max_damage_count
        14: max_support_count
        15: allow_ow1_heroes
        16: allow_ow2_heroes
        17: ready_hud
        18: ready_description_hud
        19: ult_cost
        20: health_pool
        21: PHI
        22: debug
    player:
        0: last_hero_played
        1: hero_switched
        2: hero_id
        3: initialized
        4: role
        5: allowed_heroes
        6: ready
        7: health_normal
        8: health_armor
        9: health_shields
        10: storedSpawnPosition
        11: lsi_o
        12: lsi_c
        13: lsi_r
        14: lsi_u
        15: lsi_d
        16: lsi_nabla
        17: lsi_i
        18: lsi_x
        19: self_healing_percent
        20: self_healing_modification
        21: support_passive_active
        22: last_time_damage_taken
        23: missing_ult_points
        24: ult_percent_compensated
        25: ult_charge_compensated
        26: text_huds
        27: progress_bar_huds
        28: entity_huds
        29: player_health
        30: friendly_doomfist_player
        31: friendly_orisa_player
        32: friendly_sombra_player
        33: enemy_doomfist_player
        34: enemy_orisa_player
        35: enemy_sombra_player
        36: ult_point_while_ult_active
        37: start_time_ult
        38: current_configuration
        39: sentry_gui_visibility
        40: heal_gui_visibility
        41: self_repair_time_left
        42: machine_gun_ready
        43: machine_gun_reload_timer
        44: machine_gun_ammo
        45: self_repair
        46: inspire_duration
        47: i
        48: pressing_uppercut_key
        49: shift_pressed_by_bot
        50: is_using_uppercut
        51: is_hit_by_uppercut
        52: pressing_slam_key
        53: e_pressed_by_bot
        54: is_using_slam
        55: slam_to_use
        56: current_position
        57: proto_indicator_slam_position
        58: indicator_slam_position
        59: indicator_slam_direction
        60: slam_damage
        61: slam_damage_text_entity
        62: slammed_victims
        63: indicator_entity
        64: punched_victims
        65: wall_impacted_victims
        66: punch_charge_time
        67: hero_id_duplicated
        68: flashbang_origin_position
        69: flashbang_exploded
        70: freeze_progress
        71: is_frozen
        72: freeze_slow_linger_time
        73: freeze_move_penalty
        74: is_using_supercharger
        75: is_supercharged
        76: orisa_supercharger_entity
        77: orisa_supercharger_uptime
        78: orisa_supercharger_position
        79: orisa_beam_entity
        80: orisa_beam_sound_effect
        81: is_using_halt
        82: is_snared
        83: halt_position
        84: halt_ending_position
        85: halt_entity1
        86: halt_entity2
        87: halt_pull_line_entity
        88: position
        89: barrier_projectile
        90: barrier_proj_v0
        91: barrier_proj_p0
        92: barrier_proj_t
        93: barrier_proj_velocity
        94: barrier_proj_position
        95: barrier_position
        96: barrier_orientation
        97: barrier_sample_x
        98: barrier_sample_y
        99: barrier_sample_z
        100: barrier_sample_radius
        101: barrier_sample_theta
        102: barrier_sample_point
        103: barrier_entity_positions
        104: barrier_entities
        105: barrier_uptime
        106: barrier_active
        107: barrier_health
        108: orisa_barrier_hit_positions
        109: current_ammo_count
        110: time_hook_was_active
        111: hack_damage_modifier
        112: scoped_shot_distance
        113: scoped_damage_base
        114: ow2_scoped_damage_falloff_scalar
        115: ow1_scoped_damage_falloff_scalar
        116: expected_scoped_damage
        117: self_bubble_cooldown
        118: ally_bubble_cooldown
        119: self_bubble_cd_text
        120: ally_bubble_cd_text
}
subroutines {
    0: lockTank
    1: lockDamage
    2: lockSupport
    3: unlockTank
    4: unlockDamage
    5: unlockSupport
    6: resetRoleLock
    7: clearCustomHealth
    8: applyCustomHealth
    9: findLineSphereIntersection
    10: removeSelfHealing
    11: resetHero
    12: respawnSameState
    13: initAna
    14: initAshe
    15: initBaptiste
    16: initBastion
    17: startMachineGunReload
    18: selfRepair
    19: transformInToTank
    20: transformOutOfTank
    21: initBrigitte
    22: createSlamDamageGui
    23: destroySlamDamageGui
    24: createSlamIndicatorGui
    25: destroySlamIndicatorGui
    26: initDoomfist
    27: executeUppercut
    28: detectUpercutHit
    29: executeSlam
    30: startSlamAnimation
    31: initiateGroundSlam
    32: initiateIndicatorSlam
    33: initDva
    34: initEcho
    35: initGenji
    36: initHanzo
    37: initIllari
    38: initJunkerqueen
    39: initJunkrat
    40: initKiriko
    41: initLifeweaver
    42: initLucio
    43: initMccree
    44: initMei
    45: clearFreezeEffect
    46: initMercy
    47: initMoira
    48: initOrisa
    49: startSupercharger
    50: endSupercharger
    51: shootHalt
    52: explodeHalt
    53: throwBarrier
    54: deployBarrier
    55: destroyBarrier
    56: fibonacciSphere
    57: replanishAmmo
    58: initRamattra
    59: initReaper
    60: initReinhardt
    61: initRoadhog
    62: initSigma
    63: initSoldier
    64: initSombra
    65: initSymmetra
    66: initTorbjorn
    67: initTracer
    68: initWidowmaker
    69: initWinston
    70: initWreckingball
    71: initZarya
    72: showSelfBubbleCD
    73: hideSelfBubbleCD
    74: showAllyBubbleCD
    75: hideAllyBubbleCD
    76: initZenyatta
}
rule ("Initialize global variables") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(max_tank_count, Workshop Setting Integer(Custom String("Role limit", Null, Null, Null), Custom String("Tank", Null, Null, Null), 2, 0, 6, 0));
        Set Global Variable(max_damage_count, Workshop Setting Integer(Custom String("Role limit", Null, Null, Null), Custom String("Damage", Null, Null, Null), 2, 0, 6, 1));
        Set Global Variable(max_support_count, Workshop Setting Integer(Custom String("Role limit", Null, Null, Null), Custom String("Support", Null, Null, Null), 2, 0, 6, 2));
        Set Global Variable(allow_ow1_heroes, Workshop Setting Toggle(Custom String("Heroes", Null, Null, Null), Custom String("Overwatch 1", Null, Null, Null), True, 0));
        Set Global Variable(allow_ow2_heroes, Workshop Setting Toggle(Custom String("Heroes", Null, Null, Null), Custom String("Overwatch 2", Null, Null, Null), False, 0));
        Set Global Variable(PHI, 3.883222077450933);
        Set Global Variable(debug, Workshop Setting Toggle(Custom String("Dev Tools", Null, Null, Null), Custom String("debug mode", Null, Null, Null), False, 0));
    }
}

rule ("[hero_switch.opy]: detect hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).last_hero_played != Hero Of(Event Player);
    }
    actions {
        Set Player Variable(Event Player, hero_switched, True);
        Wait(0.016, Ignore Condition);
        Set Player Variable(Event Player, last_hero_played, Hero Of(Event Player));
        Set Player Variable(Event Player, hero_id, Index Of Array Value(All Heroes, (Event Player).last_hero_played));
        Set Player Variable(Event Player, hero_switched, False);
    }
}

rule ("[role_lock.opy]: Define tank, damage, support heroes array") {
    event {
        Ongoing - Global;
    }
    actions {
        "Tanks"
        Set Global Variable(ow1_tank_heroes, All Tank Heroes);
        Modify Global Variable(ow1_tank_heroes, Remove From Array By Value, Hero(Doomfist));
        Set Global Variable(ow2_tank_heroes, Array(Hero(Junker Queen), Hero(Ramattra)));
        Modify Global Variable(ow1_tank_heroes, Remove From Array By Value, Global.ow2_tank_heroes);
        "Damage"
        Set Global Variable(ow1_damage_heroes, All Damage Heroes);
        Modify Global Variable(ow1_damage_heroes, Append To Array, Hero(Doomfist));
        Set Global Variable(ow2_damage_heroes, Array(Hero(Sojourn)));
        Modify Global Variable(ow1_damage_heroes, Remove From Array By Value, Global.ow2_damage_heroes);
        "Supports"
        Set Global Variable(ow1_support_heroes, All Support Heroes);
        Set Global Variable(ow2_support_heroes, Array(Hero(Kiriko), Hero(Lifeweaver), Hero(Illari)));
        Modify Global Variable(ow1_support_heroes, Remove From Array By Value, Global.ow2_support_heroes);
        Set Global Variable(tank_heroes, Empty Array);
        Set Global Variable(damage_heroes, Empty Array);
        Set Global Variable(support_heroes, Empty Array);
        If(Compare(Global.allow_ow1_heroes, ==, True));
            Modify Global Variable(tank_heroes, Append To Array, Global.ow1_tank_heroes);
            Modify Global Variable(damage_heroes, Append To Array, Global.ow1_damage_heroes);
            Modify Global Variable(support_heroes, Append To Array, Global.ow1_support_heroes);
        End;
        If(Compare(Global.allow_ow2_heroes, ==, True));
            Modify Global Variable(tank_heroes, Append To Array, Global.ow2_tank_heroes);
            Modify Global Variable(damage_heroes, Append To Array, Global.ow2_damage_heroes);
            Modify Global Variable(support_heroes, Append To Array, Global.ow2_support_heroes);
        End;
        Set Global Variable(all_heroes, Empty Array);
        Modify Global Variable(all_heroes, Append To Array, Global.tank_heroes);
        Modify Global Variable(all_heroes, Append To Array, Global.damage_heroes);
        Modify Global Variable(all_heroes, Append To Array, Global.support_heroes);
    }
}

rule ("[role_lock.opy]: Find player's role") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_switched == True;
    }
    actions {
        If(Array Contains(Global.tank_heroes, Hero Of(Event Player)));
            Set Player Variable(Event Player, role, 1);
        Else If(Array Contains(Global.damage_heroes, Hero Of(Event Player)));
            Set Player Variable(Event Player, role, 2);
        Else If(Array Contains(Global.support_heroes, Hero Of(Event Player)));
            Set Player Variable(Event Player, role, 3);
        Else;
            Set Player Variable(Event Player, role, 0);
    }
}

rule ("[role_lock.opy]: Skip Assemble Heroes") {
    event {
        Ongoing - Global;
    }
    conditions {
        Is Assembling Heroes == True;
    }
    actions {
        "Save assemble hero time"
        Set Global Variable(hero_select_time, Match Time);
        "Let built-in game logic reset \"allowed hero list\""
        Wait(0.016, Ignore Condition);
        "Go to the end of the assembling heroes"
        Set Match Time(0);
        Wait Until(Not(Is Assembling Heroes), 9999);
        "Give back assemble hero time"
        Set Match Time(Add(Match Time, Global.hero_select_time));
    }
}

rule ("[role_lock.opy]: Lock tanks above role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 1)))) >= Global.max_tank_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(lockTank);
    }
}

rule ("[role_lock.opy]: Lock damage above role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 2)))) >= Global.max_damage_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(lockDamage);
    }
}

rule ("[role_lock.opy]: Lock supports above role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 3)))) >= Global.max_support_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(lockSupport);
    }
}

rule ("[role_lock.opy]: Unlock tanks below role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 1)))) < Global.max_tank_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(unlockTank);
    }
}

rule ("[role_lock.opy]: Unlock damage below role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 2)))) < Global.max_damage_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(unlockDamage);
    }
}

rule ("[role_lock.opy]: Unlock supports below role limit") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Filtered Array(All Players(Team Of(Event Player)), And(Compare(Current Array Element, !=, Event Player), Compare((Current Array Element).role, ==, 3)))) < Global.max_support_count;
        Is Assembling Heroes == False;
    }
    actions {
        Call Subroutine(unlockSupport);
    }
}

rule ("[role_lock.opy]: lockTank()") {
    event {
        Subroutine;
        lockTank;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        Modify Player Variable(Event Player, allowed_heroes, Remove From Array By Value, Global.tank_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: lockDamage()") {
    event {
        Subroutine;
        lockDamage;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        Modify Player Variable(Event Player, allowed_heroes, Remove From Array By Value, Global.damage_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: lockSupport()") {
    event {
        Subroutine;
        lockSupport;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        Modify Player Variable(Event Player, allowed_heroes, Remove From Array By Value, Global.support_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: unlockTank()") {
    event {
        Subroutine;
        unlockTank;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        "eventPlayer.allowed_heroes.remove(tank_heroes)"
        Modify Player Variable(Event Player, allowed_heroes, Append To Array, Global.tank_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: unlockDamage()") {
    event {
        Subroutine;
        unlockDamage;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        "eventPlayer.allowed_heroes.remove(damage_heroes)"
        Modify Player Variable(Event Player, allowed_heroes, Append To Array, Global.damage_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: unlockSupport()") {
    event {
        Subroutine;
        unlockSupport;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Allowed Heroes(Event Player));
        "eventPlayer.allowed_heroes.remove(support_heroes)"
        Modify Player Variable(Event Player, allowed_heroes, Append To Array, Global.support_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[role_lock.opy]: resetRoleLock()") {
    event {
        Subroutine;
        resetRoleLock;
    }
    actions {
        Set Player Variable(Event Player, allowed_heroes, Global.all_heroes);
        Set Player Allowed Heroes(Event Player, (Event Player).allowed_heroes);
    }
}

rule ("[ready.opy]: Create ready HUD") {
    event {
        Ongoing - Global;
    }
    conditions {
        Is In Setup == True;
    }
    actions {
        Create HUD Text(All Players(All Teams), Custom String("{0}/{1} ready", Count Of(Filtered Array(All Players(All Teams), Compare((Current Array Element).ready, ==, True))), Number Of Players(All Teams), Null), Null, Null, Top, 9999, If-Then-Else(Is True For All(All Players(All Teams), (Current Array Element).ready), Color(Green), Color(Red)), Null, Null, String and Color, Default Visibility);
        Set Global Variable(ready_hud, Last Text ID);
        Create HUD Text(All Players(All Teams), Null, Custom String("Press {0} + {1} to ready", Input Binding String(Button(Interact)), Input Binding String(Button(Reload)), Null), Null, Top, 9999, Null, Color(White), Null, String and Color, Default Visibility);
        Set Global Variable(ready_description_hud, Last Text ID);
        Wait Until(Not(Is In Setup), 9999);
        Destroy HUD Text(Global.ready_hud);
        Destroy HUD Text(Global.ready_description_hud);
    }
}

rule ("[ready.opy]: Unready all players when entering setup") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is In Setup == True;
    }
    actions {
        Set Player Variable(Event Player, ready, False);
    }
}

rule ("[ready.opy]: Toggle ready when pressing Interact + Reload") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is In Setup == True;
        Is Button Held(Event Player, Button(Interact)) == True;
        Is Button Held(Event Player, Button(Reload)) == True;
    }
    actions {
        Set Player Variable(Event Player, ready, Not((Event Player).ready));
    }
}

rule ("[ready.opy]: Start match when everyone ready") {
    event {
        Ongoing - Global;
    }
    conditions {
        "Guard to prevent incorrect match time modification"
        Is Game In Progress == False;
        "Guard to prevent incorrect match time modification"
        Is Assembling Heroes == False;
        Is In Setup == True;
        Match Time > 5;
        Is True For All(All Players(All Teams), (Current Array Element).ready) == True;
    }
    actions {
        Set Match Time(5);
    }
}

rule ("[custom_health_handler.opy]: Clear Custom Health") {
    event {
        Subroutine;
        clearCustomHealth;
    }
    actions {
        Remove All Health Pools From Player(Event Player);
        Wait(0.016, Ignore Condition);
        Set Max Health(Event Player, 100.001);
        Wait(0.016, Ignore Condition);
        Set Max Health(Event Player, 100);
        Heal(Event Player, Null, 999999999999999);
    }
}

rule ("[custom_health_handler.opy]: Apply Custom Health") {
    event {
        Subroutine;
        applyCustomHealth;
    }
    actions {
        "If the player is in spawn, teleport them out as they are invulnerable in spawn"
        If(Is In Spawn Room(Event Player));
            Start Camera(Event Player, Eye Position(Event Player), Add(Eye Position(Event Player), Facing Direction Of(Event Player)), 0.001);
            Wait(0.032, Ignore Condition);
            Set Player Variable(Event Player, storedSpawnPosition, Position Of(Event Player));
            Teleport(Event Player, Add(Position Of(Event Player), Vector(0, 100, 0)));
            Wait Until(And(And(Not(Is In Spawn Room(Event Player)), Not(Has Status(Event Player, Invincible))), Not(Has Status(Event Player, Unkillable))), 1);
            Wait(0.016, Ignore Condition);
        End;
        "If the player is duplicating a hero, wait until Echo is no longer invulnerable"
        If(Is Duplicating(Event Player));
            Wait Until(And(Not(Has Status(Event Player, Invincible)), Not(Has Status(Event Player, Unkillable))), 1);
            Wait(0.016, Ignore Condition);
        End;
        "# Applying Custom Health ##\r\n Apply an unkillable status so we don't accidentally kill the player"
        Set Status(Event Player, Event Player, Unkillable, 1);
        "Damage the player so they're at one health"
        Damage(Event Player, Null, 999999999999999);
        Wait(0.016, Ignore Condition);
        "Apply temporary base health to the player"
        Add Health Pool To Player(Event Player, Health, 999999999999999, True, True);
        Add Health Pool To Player(Event Player, Armor, 999999999999999, True, True);
        Add Health Pool To Player(Event Player, Shields, 999999999999999, True, True);
        Wait(0.016, Ignore Condition);
        "Remove temporary base health from the player"
        Remove All Health Pools From Player(Event Player);
        Wait(0.016, Ignore Condition);
        "Apply custom health pool to player"
        If(Compare((Event Player).health_normal, >, 0));
            Add Health Pool To Player(Event Player, Health, Max(1, Subtract((Event Player).health_normal, 1)), True, True);
        End;
        If(Compare((Event Player).health_armor, >, 0));
            Add Health Pool To Player(Event Player, Armor, Max(1, (Event Player).health_armor), True, True);
        End;
        If(Compare((Event Player).health_shields, >, 0));
            Add Health Pool To Player(Event Player, Shields, Max(1, (Event Player).health_shields), True, True);
        End;
        Heal(Event Player, Null, 999999999999999);
        "Teleport player back if they were in spawn."
        If((Event Player).storedSpawnPosition);
            Wait(0.016, Ignore Condition);
            Teleport(Event Player, (Event Player).storedSpawnPosition);
            Set Player Variable(Event Player, storedSpawnPosition, Null);
            Stop Camera(Event Player);
        End;
    }
}

rule ("[custom_health_handler.opy]: Remove Custom Health Conditions") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    actions {
        "Health pools persist between hero switching, so we remove it when player's switch or duplicate to another hero, or when D.Va switches between forms."
        Wait Until(Or(Or(Compare(Hero Of(Event Player), !=, Evaluate Once(Hero Of(Event Player))), Compare(Hero Being Duplicated(Event Player), !=, Evaluate Once(Hero Being Duplicated(Event Player)))), And(Or(Compare(Hero Of(Event Player), ==, Hero(D.Va)), Compare(Hero Being Duplicated(Event Player), ==, Hero(D.Va))), Compare(Is In Alternate Form(Event Player), !=, Evaluate Once(Is In Alternate Form(Event Player))))), 9999);
        Call Subroutine(clearCustomHealth);
        Wait(0.016, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[hit_detection.opy]: findLineSphereIntersection()") {
    event {
        Subroutine;
        findLineSphereIntersection;
    }
    actions {
        Set Player Variable(Event Player, lsi_nabla, Subtract(Raise To Power(Absolute Value(Dot Product((Event Player).lsi_u, Subtract((Event Player).lsi_o, (Event Player).lsi_c))), 2), Subtract(Raise To Power(Distance Between((Event Player).lsi_o, (Event Player).lsi_c), 2), Raise To Power((Event Player).lsi_r, 2))));
        "line goes through sphere"
        If(Compare((Event Player).lsi_nabla, >, 0));
            Set Player Variable(Event Player, lsi_d, Array(Subtract(Multiply(-1, Dot Product((Event Player).lsi_u, Subtract((Event Player).lsi_o, (Event Player).lsi_c))), Square Root((Event Player).lsi_nabla)), Add(Multiply(-1, Dot Product((Event Player).lsi_u, Subtract((Event Player).lsi_o, (Event Player).lsi_c))), Square Root((Event Player).lsi_nabla))));
        "line tangent to sphere"
        Else If(Compare((Event Player).lsi_nabla, ==, 0));
            Set Player Variable(Event Player, lsi_d, Array(Multiply(-1, Dot Product((Event Player).lsi_u, Subtract((Event Player).lsi_o, (Event Player).lsi_c)))));
        "no intersection/solution"
        Else If(Compare((Event Player).lsi_nabla, <, 0));
            Set Player Variable(Event Player, lsi_d, Empty Array);
        Else;
            Set Player Variable(Event Player, lsi_d, Empty Array);
        End;
        Set Player Variable(Event Player, lsi_x, Empty Array);
        For Player Variable(Event Player, lsi_i, 0, Count Of((Event Player).lsi_d), 1);
            If(Compare(Value In Array((Event Player).lsi_d, (Event Player).lsi_i), >=, 0));
                Modify Player Variable(Event Player, lsi_x, Append To Array, Add((Event Player).lsi_o, Multiply(Value In Array((Event Player).lsi_d, (Event Player).lsi_i), (Event Player).lsi_u)));
            End;
        End;
    }
}

rule ("[no_support_passive.opy]: removeSelfHealing()") {
    event {
        Subroutine;
        removeSelfHealing;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 0);
        Start Healing Modification(Event Player, Event Player, (Event Player).self_healing_percent, Receivers Healers and Healing Percent);
        Set Player Variable(Event Player, self_healing_modification, Last Healing Modification ID);
    }
}

rule ("[no_support_passive.opy]: Get time when support hero take damage") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Array Contains(Global.support_heroes, Hero Of(Event Player)) == True;
    }
    actions {
        Set Player Variable(Event Player, last_time_damage_taken, Total Time Elapsed);
        Set Player Variable(Event Player, support_passive_active, False);
    }
}

rule ("[no_support_passive.opy]: Check if support passive is active") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).support_passive_active == False;
        Array Contains(Global.support_heroes, Hero Of(Event Player)) == True;
        Subtract(Total Time Elapsed, (Event Player).last_time_damage_taken) > 1.5;
    }
    actions {
        Set Player Variable(Event Player, support_passive_active, True);
    }
}

rule ("[ult_charge.opy]: initialize overwatch 1 ultimate costs") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(D.Va)), 1540);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Reinhardt)), 1542.056074766355);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Roadhog)), 2240.7407407407404);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Sigma)), 1962.6168224299065);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Winston)), 1541.6666666666667);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Wrecking Ball)), 1536.6972477064219);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Zarya)), 2101.8518518518517);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Ashe)), 2240);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Bastion)), 2310);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Cassidy)), 1681.8181818181818);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Echo)), 2254.6666666666665);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Genji)), 1932);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Hanzo)), 1680);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Junkrat)), 1925);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Mei)), 1605.5045871559632);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Pharah)), 2105.2631578947367);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Reaper)), 2097.8260869565215);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Soldier: 76)), 2310);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Sombra)), 1400.0000000000002);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Symmetra)), 1680);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Torbjörn)), 2142);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Tracer)), 1260);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Widowmaker)), 1540);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Ana)), 2100);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Baptiste)), 2310);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Brigitte)), 2786.5979381443303);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Lúcio)), 2951.2195121951218);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Mercy)), 1820);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Moira)), 2800);
        Set Global Variable At Index(ult_cost, Index Of Array Value(All Heroes, Hero(Zenyatta)), 2310);
    }
}

rule ("[ult_charge.opy]: Remember missing ult charge from damaging tank") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Victim != Event Player;
        Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Modify Player Variable(Event Player, missing_ult_points, Add, Multiply(0.3, Event Damage));
    }
}

rule ("[ult_charge.opy]: Remember missing ult charge from healing tank") {
    event {
        Player Dealt Healing;
        All;
        All;
    }
    conditions {
        Array Contains(All Tank Heroes, Hero Of(Healee)) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Modify Player Variable(Event Player, missing_ult_points, Add, Multiply(0.3, Event Healing));
    }
}

rule ("[ult_charge.opy]: Compensate missing ultimate percentage") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).missing_ult_points > 0;
    }
    actions {
        "add 3% extra to compensate for rounding error"
        Set Player Variable(Event Player, ult_percent_compensated, Add(Divide(Multiply(100, (Event Player).missing_ult_points), Value In Array(Global.ult_cost, (Event Player).hero_id)), 3));
        Set Ultimate Charge(Event Player, Add(Ultimate Charge Percent(Event Player), (Event Player).ult_percent_compensated));
        Set Player Variable(Event Player, ult_charge_compensated, Multiply(Divide((Event Player).ult_percent_compensated, 100), Value In Array(Global.ult_cost, (Event Player).hero_id)));
        Modify Player Variable(Event Player, missing_ult_points, Subtract, (Event Player).ult_charge_compensated);
    }
}

rule ("[ult_charge.opy]: Reset ult compensation after using ult") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, missing_ult_points, 0);
        Set Player Variable(Event Player, ult_percent_compensated, 0);
    }
}

rule ("[reset_hero.opy]: Reset hero stats/gui") {
    event {
        Subroutine;
        resetHero;
    }
    actions {
        Set Primary Fire Enabled(Event Player, True);
        Allow Button(Event Player, Button(Primary Fire));
        Set Secondary Fire Enabled(Event Player, True);
        Allow Button(Event Player, Button(Secondary Fire));
        Set Melee Enabled(Event Player, True);
        Allow Button(Event Player, Button(Melee));
        Set Ability 1 Enabled(Event Player, True);
        Allow Button(Event Player, Button(Ability 1));
        Set Ability 2 Enabled(Event Player, True);
        Allow Button(Event Player, Button(Ability 2));
        Set Ultimate Ability Enabled(Event Player, True);
        Allow Button(Event Player, Button(Ultimate));
        Set Ultimate Charge(Event Player, 0);
        Set Player Variable(Event Player, missing_ult_points, 0);
        Set Player Variable(Event Player, ult_percent_compensated, 0);
        Set Damage Dealt(Event Player, 100);
        Set Damage Received(Event Player, 100);
        Set Projectile Speed(Event Player, 100);
        Set Projectile Gravity(Event Player, 100);
        Set Healing Dealt(Event Player, 100);
        Set Healing Received(Event Player, 100);
        Stop Healing Modification((Event Player).self_healing_modification);
        Set Knockback Received(Event Player, 100);
        Set Knockback Dealt(Event Player, 100);
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, support_passive_active, True);
        Clear Status(Event Player, Rooted);
        Set Player Variable(Event Player, friendly_doomfist_player, First Of(Players On Hero(Hero(Doomfist), Team Of(Event Player))));
        Set Player Variable(Event Player, enemy_doomfist_player, First Of(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player)))));
        Set Player Variable(Event Player, friendly_orisa_player, First Of(Players On Hero(Hero(Orisa), Team Of(Event Player))));
        Set Player Variable(Event Player, enemy_orisa_player, First Of(Players On Hero(Hero(Orisa), Opposite Team Of(Team Of(Event Player)))));
        Set Player Variable(Event Player, friendly_sombra_player, First Of(Players On Hero(Hero(Sombra), Team Of(Event Player))));
        Set Player Variable(Event Player, enemy_sombra_player, First Of(Players On Hero(Hero(Sombra), Opposite Team Of(Team Of(Event Player)))));
        "Clear GUI"
        For Global Variable(i, 0, Count Of((Event Player).text_huds), 1);
            Destroy HUD Text(Value In Array((Event Player).text_huds, Global.i));
        End;
        For Global Variable(i, 0, Count Of((Event Player).progress_bar_huds), 1);
            Destroy Progress Bar HUD Text(Value In Array((Event Player).progress_bar_huds, Global.i));
        End;
        For Global Variable(i, 0, Count Of((Event Player).entity_huds), 1);
            Destroy Effect(Value In Array((Event Player).entity_huds, Global.i));
        End;
        Set Player Variable(Event Player, text_huds, Empty Array);
        Set Player Variable(Event Player, progress_bar_huds, Empty Array);
        Set Player Variable(Event Player, entity_huds, Empty Array);
        Set Player Variable(Event Player, initialized, False);
    }
}

rule ("[reset_hero.opy]: Reset hero on new round") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Between Rounds == True;
    }
    actions {
        Wait Until(Not(Is Between Rounds), 9999);
        Call Subroutine(resetHero);
    }
}

rule ("[reset_hero.opy]: Reset hero on hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_switched == True;
    }
    actions {
        Wait(0.016, Ignore Condition);
        Call Subroutine(resetHero);
    }
}

rule ("[reset_hero.opy]: respawnSameState()") {
    event {
        Subroutine;
        respawnSameState;
    }
    actions {
        Set Player Variable(Event Player, player_health, Health(Event Player));
        Kill(Event Player, Null);
        "Use resurrect to keep the same position and angle"
        Resurrect(Event Player);
        "Wait to set health else the player will be full life"
        Wait(0.016, Ignore Condition);
        Set Player Health(Event Player, (Event Player).player_health);
    }
}

rule ("[ana.opy]: Initialize Ana") {
    event {
        Ongoing - Each Player;
        All;
        Ana;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initAna);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[ana.opy]: initAna()") {
    event {
        Subroutine;
        initAna;
    }
    actions {
        Set Ammo(Event Player, 0, 12);
        Set Max Ammo(Event Player, 0, 12);
        Call Subroutine(removeSelfHealing);
    }
}

rule ("[ana.opy]: Set default sleep dart cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Ana;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 9999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 12);
    }
}

rule ("[ana.opy]: Sleep tanks for longer duration") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Array Contains(All Tank Heroes, Hero Of(Event Player)) == True;
        Has Status(Event Player, Asleep) == True;
    }
    actions {
        "5/3.5 is the ratio of regular sleep time to tank sleep time"
        Set Status(Event Player, Null, Asleep, 7.692307692307692);
    }
}

rule ("[ana.opy]: Heal OW1 healing with biotic grenade") {
    event {
        Player Dealt Healing;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Heal(Healee, Healer, Subtract(Multiply(Event Healing, 1.666666666666666), Event Healing));
    }
}

rule ("[ana.opy]: Allow self healing during Biotic Grenade") {
    event {
        Ongoing - Each Player;
        All;
        Ana;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ability 2(Event Player)), 9999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[ashe.opy]: Initialize Ashe") {
    event {
        Ongoing - Each Player;
        All;
        Ashe;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initAshe);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[ashe.opy]: Add ultimate charge while using BOB") {
    event {
        Ongoing - Each Player;
        All;
        Ashe;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, ult_point_while_ult_active, 0);
        Set Player Variable(Event Player, start_time_ult, Total Time Elapsed);
        Wait Until(Not(Is Using Ultimate(Event Player)), 99999);
        "Check if the user did not switch hero after using B.O.B to add the ult charge"
        If(Compare(Hero Of(Event Player), ==, Hero(Ashe)));
            "Add charge for passive generation and then the ult charge generated from the damage made by Ashe"
            Set Player Variable(Event Player, missing_ult_points, Add(Multiply(5, Subtract(Total Time Elapsed, (Event Player).start_time_ult)), (Event Player).ult_point_while_ult_active));
    }
}

rule ("[ashe.opy]: Calcul of the damage made while BOB is active") {
    event {
        Player Dealt Damage;
        All;
        Ashe;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Victim != Attacker;
    }
    actions {
        If(Array Contains(All Tank Heroes, Hero Of(Victim)));
            Modify Player Variable(Event Player, ult_point_while_ult_active, Add, Multiply(1.3, Event Damage));
        Else;
            Modify Player Variable(Event Player, ult_point_while_ult_active, Add, Event Damage);
    }
}

rule ("[baptiste.opy]: Initialize Baptiste") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initBaptiste);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[baptiste.opy]: initBaptiste()") {
    event {
        Subroutine;
        initBaptiste;
    }
    actions {
        Set Ammo(Event Player, 0, 45);
        Set Max Ammo(Event Player, 0, 45);
        Set Ammo(Event Player, 1, 10);
        Set Max Ammo(Event Player, 1, 10);
        Call Subroutine(removeSelfHealing);
    }
}

rule ("[baptiste.opy]: Set default immortality field cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 9999);
        Set Ability Cooldown(Event Player, Button(Ability 2), 25);
    }
}

rule ("[baptiste.opy]: Allow self healing during Biotic Orb") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait(5, Ignore Condition);
        "waitUntil(eventPlayer.isUsingAbility1() == false, 9999)"
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[bastion.opy]: Initialize Bastion") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initBastion);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[bastion.opy]: initBastion()") {
    event {
        Subroutine;
        initBastion;
    }
    actions {
        Set Player Variable(Event Player, self_repair_time_left, 3.333333333333333);
        Set Player Variable(Event Player, machine_gun_ammo, 300);
        Set Player Variable(Event Player, machine_gun_reload_timer, 0);
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Player Variable(Event Player, sentry_gui_visibility, Null);
        Set Player Variable(Event Player, heal_gui_visibility, Null);
        "Initialize GUI"
        Create Progress Bar HUD Text((Event Player).sentry_gui_visibility, Round To Integer(Divide(Multiply(100, (Event Player).machine_gun_ammo), 300), To Nearest), Custom String("Ammo: {0}", Round To Integer((Event Player).machine_gun_ammo, Up), Null, Null), Top, 0, Color(Orange), Color(Orange), Visible To Values and Color, Default Visibility);
        Modify Player Variable(Event Player, progress_bar_huds, Append To Array, Last Text ID);
        Create Progress Bar HUD Text((Event Player).heal_gui_visibility, Round To Integer(Divide(Multiply(100, (Event Player).self_repair_time_left), 3.333333333333333), To Nearest), Custom String("Self-Repair", Null, Null, Null), Left, 1, Color(Yellow), Color(Yellow), Visible To Values and Color, Default Visibility);
        Modify Player Variable(Event Player, progress_bar_huds, Append To Array, Last Text ID);
    }
}

rule ("[bastion.opy]: Hide Bastion HUD on hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_switched == True;
        Hero Of(Event Player) != Hero(Bastion);
    }
    actions {
        Set Player Variable(Event Player, sentry_gui_visibility, Null);
        Set Player Variable(Event Player, heal_gui_visibility, Null);
    }
}

rule ("[bastion.opy]: No cooldown on reconfigure (ability 1)") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
    }
}

rule ("[bastion.opy]: start machine gun reload timer") {
    event {
        Subroutine;
        startMachineGunReload;
    }
    actions {
        Abort If(Compare((Event Player).machine_gun_ammo, >=, 300));
        If(Compare((Event Player).current_configuration, ==, 1));
            Small Message(Event Player, Custom String("Reloading . . .", Null, Null, Null));
        End;
        Set Player Variable(Event Player, machine_gun_ready, False);
        Set Player Variable(Event Player, machine_gun_reload_timer, 1.984);
        Chase Player Variable At Rate(Event Player, machine_gun_reload_timer, 0, 1, Destination and Rate);
    }
}

rule ("[bastion.opy]: finish reloading machine gun") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).machine_gun_reload_timer <= 0;
    }
    actions {
        Set Player Variable(Event Player, machine_gun_ammo, 300);
        Set Player Variable(Event Player, machine_gun_ready, True);
        If(Compare((Event Player).current_configuration, ==, 1));
            Small Message(Event Player, Custom String("Done", Null, Null, Null));
    }
}

rule ("[bastion.opy]: Define recon mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        "built in workshop function for detecting default hero form"
        Is In Alternate Form(Event Player) == False;
    }
    actions {
        Set Player Variable(Event Player, current_configuration, 0);
    }
}

rule ("[bastion.opy]: Initialize recon mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 0;
    }
    actions {
        Set Move Speed(Event Player, 100);
        Set Damage Dealt(Event Player, 100);
        Set Projectile Speed(Event Player, 100);
        Set Projectile Gravity(Event Player, 100);
        Disallow Button(Event Player, Button(Secondary Fire));
        Clear Status(Event Player, Rooted);
        Set Knockback Received(Event Player, 100);
        Allow Button(Event Player, Button(Primary Fire));
    }
}

rule ("[bastion.opy]: Define sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is In Alternate Form(Event Player) == True;
        "Sentry mode can only be entered from recon mode"
        (Event Player).current_configuration == 0;
        "prevents incorrectly identifying tank as sentry"
        (Event Player).current_configuration != 2;
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, current_configuration, 1);
    }
}

rule ("[bastion.opy]: Initialize sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
    }
    actions {
        Set Damage Dealt(Event Player, 125);
        Set Status(Event Player, Null, Rooted, 9999);
        Set Knockback Received(Event Player, 0);
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Player Variable(Event Player, machine_gun_ready, True);
        Stop Chasing Player Variable(Event Player, machine_gun_reload_timer);
    }
}

rule ("[bastion.opy]: Define tank mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, current_configuration, 2);
    }
}

rule ("[bastion.opy]: Initialize tank mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 2;
    }
    actions {
        "move faster in tank mode"
        Set Move Speed(Event Player, 153.84615384615384);
        "deal more damage in tank mode"
        Set Damage Dealt(Event Player, 178.2608695652174);
        "increase grenade travel speed (to mimic tank shells)"
        Set Projectile Speed(Event Player, 150);
        Set Projectile Gravity(Event Player, 5);
        "Disallow firing machine gun"
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Clear Status(Event Player, Rooted);
        Set Knockback Received(Event Player, 100);
    }
}

rule ("[bastion.opy]: Show sentry gui when in sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
    }
    actions {
        Set Player Variable(Event Player, sentry_gui_visibility, Event Player);
    }
}

rule ("[bastion.opy]: Hide sentry gui when not in sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration != 1;
    }
    actions {
        Set Player Variable(Event Player, sentry_gui_visibility, Null);
    }
}

rule ("[bastion.opy]: Consume machine gun ammo when shooting") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        Is Firing Primary(Event Player) == True;
    }
    actions {
        Chase Player Variable At Rate(Event Player, machine_gun_ammo, 0, 30, Destination and Rate);
    }
}

rule ("[bastion.opy]: Stop machine gun ammo consumption when not shooting") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        And(Compare((Event Player).current_configuration, ==, 1), Is Firing Primary(Event Player)) == False;
    }
    actions {
        Stop Chasing Player Variable(Event Player, machine_gun_ammo);
    }
}

rule ("[bastion.opy]: Reload machine gun on reload key") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        Is Button Held(Event Player, Button(Reload)) == True;
    }
    actions {
        Call Subroutine(startMachineGunReload);
    }
}

rule ("[bastion.opy]: Reload machine gun if out of ammo") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        (Event Player).machine_gun_ammo <= 0;
    }
    actions {
        Call Subroutine(startMachineGunReload);
    }
}

rule ("[bastion.opy]: Reload machine gun when not in sentry mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration != 1;
    }
    actions {
        Call Subroutine(startMachineGunReload);
    }
}

rule ("[bastion.opy]: Allow machine gun shooting when machine gun ready") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        "gun ready to shoot"
        (Event Player).machine_gun_ready == True;
    }
    actions {
        Allow Button(Event Player, Button(Primary Fire));
    }
}

rule ("[bastion.opy]: Disallow machine gun shooting when machine gun not ready") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 1;
        "gun not ready to shoot"
        (Event Player).machine_gun_ready == False;
    }
    actions {
        Disallow Button(Event Player, Button(Primary Fire));
    }
}

rule ("[bastion.opy]: Execute self-repair ability") {
    event {
        Subroutine;
        selfRepair;
    }
    actions {
        Wait(0.5, Ignore Condition);
        "Approximate 90 healing over time using discrete healing at high frequency"
        While(Compare((Event Player).self_repair, ==, True));
            Heal(Event Player, Event Player, 7);
            Wait(0.077777777777777, Ignore Condition);
            Modify Player Variable(Event Player, missing_ult_points, Add, 7);
        End;
    }
}

rule ("[bastion.opy]: Activate self-repair") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).self_repair == True;
    }
    actions {
        Call Subroutine(selfRepair);
    }
}

rule ("[bastion.opy]: Start self-repair on ability 2 or secondary fire") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Or(Is Button Held(Event Player, Button(Ability 2)), Is Button Held(Event Player, Button(Secondary Fire))) == True;
        Is Firing Primary(Event Player) == False;
        Health(Event Player) < Max Health(Event Player);
        Is Alive(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_repair, True);
    }
}

rule ("[bastion.opy]: Stop self-repair on ability 2 release") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Or(Not(Or(Is Button Held(Event Player, Button(Ability 2)), Is Button Held(Event Player, Button(Secondary Fire)))), Is Firing Primary(Event Player)) == True;
    }
    actions {
        Set Player Variable(Event Player, self_repair, False);
    }
}

rule ("[bastion.opy]: Stop self-repair and hide its GUI on death") {
    event {
        Player Died;
        All;
        Bastion;
    }
    actions {
        Set Player Variable(Event Player, self_repair, False);
        Set Player Variable(Event Player, heal_gui_visibility, Null);
    }
}

rule ("[bastion.opy]: Stop self-repair when no healing resource left") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).self_repair_time_left <= 0;
    }
    actions {
        Set Player Variable(Event Player, self_repair, False);
    }
}

rule ("[bastion.opy]: Stop self-repair when full hp") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Health(Event Player) >= Max Health(Event Player);
    }
    actions {
        Set Player Variable(Event Player, self_repair, False);
    }
}

rule ("[bastion.opy]: Show self-repair GUI") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).self_repair_time_left < 3.333333333333333;
    }
    actions {
        Set Player Variable(Event Player, heal_gui_visibility, Event Player);
    }
}

rule ("[bastion.opy]: Hide self-repair GUI") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).self_repair_time_left >= 3.333333333333333;
    }
    actions {
        Set Player Variable(Event Player, heal_gui_visibility, Null);
    }
}

rule ("[bastion.opy]: Consume heal resource on self-repair") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).self_repair == True;
    }
    actions {
        "Stop any ongoing resource modification"
        Stop Chasing Player Variable(Event Player, self_repair_time_left);
        "wait self-repair animation casttime"
        Wait Until(Not((Event Player).self_repair), 0.5);
        "player interrupted self-repair"
        Abort If(Not((Event Player).self_repair));
        "Start depleting"
        Chase Player Variable At Rate(Event Player, self_repair_time_left, 0, 1, Destination and Rate);
    }
}

rule ("[bastion.opy]: Recharge heal resource when not self-repairing") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).self_repair == False;
    }
    actions {
        "Stop any ongoing resource modification"
        Stop Chasing Player Variable(Event Player, self_repair_time_left);
        "Wait 1 second cooldown before recharging heal resource"
        Wait Until((Event Player).self_repair, 1);
        "player interrupted self-repair"
        Abort If((Event Player).self_repair);
        "Start recharging"
        Chase Player Variable At Rate(Event Player, self_repair_time_left, 3.333333333333333, 0.476190476190476, Destination and Rate);
    }
}

rule ("[bastion.opy]: Transform into tank") {
    event {
        Subroutine;
        transformInToTank;
    }
    actions {
        Wait(0.5, Ignore Condition);
        "interrupt ultimate animation right before it completes"
        Cancel Primary Action(Event Player);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        "Go to turret mode"
        Press Button(Event Player, Button(Ability 1));
        "Disable reconfiguring out of turret mode"
        Disallow Button(Event Player, Button(Ability 1));
    }
}

rule ("[bastion.opy]: Transform out of tank") {
    event {
        Subroutine;
        transformOutOfTank;
    }
    actions {
        If(Is Using Ability 1(Event Player));
            Set Ability Cooldown(Event Player, Button(Ability 1), 0);
            "Go to recon mode"
            Press Button(Event Player, Button(Ability 1));
        End;
        Allow Button(Event Player, Button(Ability 1));
    }
}

rule ("[bastion.opy]: Enter tank mode") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 2;
    }
    actions {
        Call Subroutine(transformInToTank);
        Wait Until(Not(Is Using Ability 1(Event Player)), 8);
        Call Subroutine(transformOutOfTank);
    }
}

rule ("[bastion.opy]: Fire tank shells") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 2;
        Is Button Held(Event Player, Button(Primary Fire)) == True;
    }
    actions {
        Allow Button(Event Player, Button(Secondary Fire));
        Press Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Wait(0.016, Ignore Condition);
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), <=, 0), 9999);
        Loop If Condition Is True;
    }
}

rule ("[bastion.opy]: Reload tank shells") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).current_configuration == 2;
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        "modify cooldown for tank shell"
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0.75);
        "Wait tank shell reload time"
        Wait(0.75, Ignore Condition);
        "Set tank shell as available"
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
    }
}

rule ("[brigitte.opy]: Initialize Brigitte") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initBrigitte);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[brigitte.opy]: initBrigitte()") {
    event {
        Subroutine;
        initBrigitte;
    }
    actions {
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, health_normal, 150);
        Set Player Variable(Event Player, health_armor, 50);
        Set Player Variable(Event Player, health_shields, 0);
        Call Subroutine(applyCustomHealth);
        Wait(1, Ignore Condition);
        Loop If(Compare(Max Health(Event Player), !=, 200));
        Call Subroutine(removeSelfHealing);
    }
}

rule ("[brigitte.opy]: Fix inspire self heal") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    actions {
        Stop Chasing Player Variable(Event Player, inspire_duration);
        Set Player Variable(Event Player, inspire_duration, 0);
        Chase Player Variable At Rate(Event Player, inspire_duration, 6, 1, None);
        Set Player Variable(Event Player, self_healing_percent, 100);
    }
}

rule ("[brigitte.opy]: No self healing when inspire timer runs out") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        (Event Player).inspire_duration >= 6;
    }
    actions {
        Stop Chasing Player Variable(Event Player, inspire_duration);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[brigitte.opy]: Add stun to shield bash") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Event Ability == Button(Primary Fire);
    }
    actions {
        Set Status(Victim, Event Player, Stunned, 0.75);
    }
}

rule ("[brigitte.opy]: Reduce shield bash distance") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Firing Primary(Event Player) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        "arbitrarily decided based on trial and error"
        Set Move Speed(Event Player, 77.8);
        Wait Until(Not(Is Firing Primary(Event Player)), 1);
        If(Is Using Ultimate(Event Player));
            Set Move Speed(Event Player, 113.04347826086958);
        Else;
            Set Move Speed(Event Player, 100);
    }
}

rule ("[brigitte.opy]: Rally 30% speed boost") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        "30% movement speed buff during ralley"
        Set Move Speed(Event Player, 113.04347826086958);
        Wait Until(Not(Is Using Ultimate(Event Player)), 10);
        Set Move Speed(Event Player, 100);
    }
}

rule ("[doomfist.opy]: Initialize Doomfist") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initDoomfist);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[doomfist.opy]: initDoomfist()") {
    event {
        Subroutine;
        initDoomfist;
    }
    actions {
        "Set Doomfist health to OW1"
        While(Compare(Max Health(Event Player), !=, 250));
            Call Subroutine(clearCustomHealth);
            Set Player Variable(Event Player, health_normal, 250);
            Set Player Variable(Event Player, health_armor, 0);
            Set Player Variable(Event Player, health_shields, 0);
            Call Subroutine(applyCustomHealth);
            Wait(1, Ignore Condition);
        End;
        "Decouple ability button press from trigerring ability"
        Disallow Button(Event Player, Button(Ability 1));
        Disallow Button(Event Player, Button(Ability 2));
        "Variables for swapping keybinds"
        Set Player Variable(Event Player, shift_pressed_by_bot, False);
        Set Player Variable(Event Player, e_pressed_by_bot, False);
        Set Player Variable(Event Player, punched_victims, Empty Array);
        Set Player Variable(Event Player, wall_impacted_victims, Empty Array);
        "Below variables are also declared and initialized in reset_hero.opy"
        Set Player Variable(All Players(Team Of(Event Player)), friendly_doomfist_player, Event Player);
        Set Player Variable(All Players(Opposite Team Of(Team Of(Event Player))), enemy_doomfist_player, Event Player);
    }
}

rule ("[doomfist.opy]: Detect shift key press by human") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 1)) == True;
        (Event Player).shift_pressed_by_bot == False;
    }
    actions {
        Set Player Variable(Event Player, pressing_slam_key, True);
        Wait Until(Not(Is Button Held(Event Player, Button(Ability 1))), 9999);
        Set Player Variable(Event Player, pressing_slam_key, False);
    }
}

rule ("[doomfist.opy]: Detect e key press by human") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        (Event Player).e_pressed_by_bot == False;
    }
    actions {
        Set Player Variable(Event Player, pressing_uppercut_key, True);
        Wait Until(Not(Is Button Held(Event Player, Button(Ability 2))), 9999);
        Set Player Variable(Event Player, pressing_uppercut_key, False);
    }
}

rule ("[doomfist.opy]: Control flow for uppercut") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).pressing_uppercut_key == True;
        (Event Player).is_using_slam == False;
        Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
        "@Condition not eventPlayer.hasStatusEffect(Status.HACKED) # Ensure Doomfist is not hacked\r\n Ensure Doomfist is not frozen"
        Has Status(Event Player, Frozen) == False;
        "Ensure Doomfist is not knocked down"
        Has Status(Event Player, Knocked Down) == False;
        "Ensure Doomfist is not asleep"
        Has Status(Event Player, Asleep) == False;
        "Ensure Doomfist is not stunned"
        Has Status(Event Player, Stunned) == False;
    }
    actions {
        Call Subroutine(executeUppercut);
    }
}

rule ("[doomfist.opy]: Control flow for slam") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).pressing_slam_key == True;
        (Event Player).is_using_uppercut == False;
        Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
        "@Condition not eventPlayer.hasStatusEffect(Status.HACKED) # Ensure Doomfist is not hacked\r\n Ensure Doomfist is not frozen"
        Has Status(Event Player, Frozen) == False;
        "Ensure Doomfist is not knocked down"
        Has Status(Event Player, Knocked Down) == False;
        "Ensure Doomfist is not asleep"
        Has Status(Event Player, Asleep) == False;
        "Ensure Doomfist is not stunned"
        Has Status(Event Player, Stunned) == False;
    }
    actions {
        Call Subroutine(executeSlam);
    }
}

rule ("[doomfist.opy]: executeUppercut()") {
    event {
        Subroutine;
        executeUppercut;
    }
    actions {
        "Doomfist phases through enemies during uppercut"
        Disable Movement Collision With Players(Event Player);
        "Uppercut physics\r\n Start of uppercut"
        Set Player Variable(Event Player, is_using_uppercut, True);
        "Cancel current momentum"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
        "Step Forward"
        Apply Impulse(Event Player, Normalize(Multiply(Facing Direction Of(Event Player), Add(Forward, Left))), 5, To World, Incorporate Contrary Motion);
        "Override gravity during uppercut"
        Set Gravity(Event Player, 0);
        "Deny player from inputting movement commands"
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Wait(0.15, Ignore Condition);
        "Uppercut"
        Apply Impulse(Event Player, Up, 40, To World, Incorporate Contrary Motion);
        Wait(0.1, Ignore Condition);
        Apply Impulse(Event Player, Down, Max(0, Speed Of In Direction(Event Player, Up)), To World, Incorporate Contrary Motion);
        "End of uppercut"
        Set Player Variable(Event Player, is_using_uppercut, False);
        Wait(0.016, Ignore Condition);
        Apply Impulse(Event Player, Up, 2.5, To World, Incorporate Contrary Motion);
        Set Gravity(Event Player, 0);
        Enable Movement Collision With Players(Event Player);
        Wait(0.35, Ignore Condition);
        Stop Forcing Throttle(Event Player);
        Wait(0.15, Ignore Condition);
        Set Gravity(Event Player, 50);
        Wait(0.25, Ignore Condition);
        Set Gravity(Event Player, 100);
    }
}

rule ("[doomfist.opy]: Play uppercut VFX") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_uppercut == True;
    }
    actions {
        Play Effect(All Players(All Teams), Explosion Sound, Team Of(Event Player), Event Player, 100);
        Play Effect(All Players(All Teams), Debuff Impact Sound, Team Of(Event Player), Event Player, 100);
        Play Effect(All Players(All Teams), Ring Explosion Sound, Team Of(Event Player), Event Player, 100);
    }
}

rule ("[doomfist.opy]: Set uppercut cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_uppercut == True;
    }
    actions {
        Wait Until(Compare((Event Player).is_using_uppercut, ==, False), 9999);
        Set Ability Cooldown(Event Player, Button(Ability 2), 6);
    }
}

rule ("[doomfist.opy]: Disable abilities when uppercutting") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_uppercut == True;
    }
    actions {
        "Doomfist cannot melee during uppercut"
        Set Melee Enabled(Event Player, False);
        "Doomfist cannot shoot during uppercut"
        Set Primary Fire Enabled(Event Player, False);
        "Doomfist cannot punch during uppercut"
        Set Secondary Fire Enabled(Event Player, False);
        Wait Until(Compare((Event Player).is_using_uppercut, ==, False), 9999);
        Set Melee Enabled(Event Player, True);
        Set Primary Fire Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, True);
    }
}

rule ("[doomfist.opy]: Detect uppercut victims") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        "Enemy doomfist using uppercut"
        ((Event Player).enemy_doomfist_player).is_using_uppercut == True;
        "Victim within uppercut hitbox range"
        Distance Between((Event Player).enemy_doomfist_player, Event Player) <= 5;
        "Victim in los of doomfist"
        Is In Line of Sight((Event Player).enemy_doomfist_player, Event Player, Barriers Do Not Block LOS) == True;
        "Victim visible to doomfist"
        Angle Between Vectors(Normalize(Multiply(Facing Direction Of((Event Player).enemy_doomfist_player), Add(Forward, Left))), Direction Towards((Event Player).enemy_doomfist_player, Event Player)) <= 90;
        "Enemy doomfist alive"
        Is Alive((Event Player).enemy_doomfist_player) == True;
        "Victim is alive"
        Is Alive(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, is_hit_by_uppercut, True);
    }
}

rule ("[doomfist.opy]: Uppercut victim movement physics") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_hit_by_uppercut == True;
    }
    actions {
        "Lose movement control"
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Apply Impulse(Event Player, Up, 13.5, To Player, Cancel Contrary Motion XYZ);
        Apply Impulse(Event Player, Normalize(Multiply(Facing Direction Of((Event Player).enemy_doomfist_player), Add(Forward, Left))), 8.5, To World, Cancel Contrary Motion XYZ);
        Wait(0.6, Ignore Condition);
        "Regain movement control"
        Stop Forcing Throttle(Event Player);
        Set Player Variable(Event Player, is_hit_by_uppercut, False);
    }
}

rule ("[doomfist.opy]: Damage uppercut victims") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_hit_by_uppercut == True;
    }
    actions {
        Damage(Event Player, (Event Player).enemy_doomfist_player, 50);
        Set Environment Credit Player(Event Player, (Event Player).enemy_doomfist_player);
    }
}

rule ("[doomfist.opy]: Play uppercut hit VFX") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_hit_by_uppercut == True;
    }
    actions {
        Play Effect(All Players(All Teams), Bad Explosion, Color(White), Event Player, 1);
    }
}

rule ("[doomfist.opy]: Detect ground slam") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Update Every Frame(Compare(Altitude Of(Event Player), <, 3)) != False;
    }
    actions {
        Set Player Variable(Event Player, slam_to_use, 0);
    }
}

rule ("[doomfist.opy]: Detect indicator slam") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Update Every Frame(Compare(Altitude Of(Event Player), >=, 3)) != False;
    }
    actions {
        Set Player Variable(Event Player, slam_to_use, 1);
    }
}

rule ("[doomfist.opy]: Start tracking indicator slam destination") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).slam_to_use == 1;
        Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        Chase Player Variable At Rate(Event Player, proto_indicator_slam_position, Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(15, Facing Direction Of(Event Player))), Null, Null, First Of(Null)), 9999, Destination and Rate);
        Chase Player Variable At Rate(Event Player, indicator_slam_position, Ray Cast Hit Position((Event Player).proto_indicator_slam_position, Add((Event Player).proto_indicator_slam_position, Multiply(5, Down)), Null, All Players(All Teams), False), 9999, Destination and Rate);
    }
}

rule ("[doomfist.opy]: Stop tracking indicator slam destination") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        And(And(Compare((Event Player).slam_to_use, ==, 1), Compare(Ability Cooldown(Event Player, Button(Ability 1)), <=, 0)), Not(Is Using Ability 1(Event Player))) == False;
    }
    actions {
        Stop Chasing Player Variable(Event Player, proto_indicator_slam_position);
        Stop Chasing Player Variable(Event Player, indicator_slam_position);
    }
}

rule ("[doomfist.opy]: executeSlam()") {
    event {
        Subroutine;
        executeSlam;
    }
    actions {
        "clear slammed victims"
        Set Player Variable(Event Player, slammed_victims, Empty Array);
        If(Compare((Event Player).slam_to_use, ==, 1));
            "Only execute when indicator slam is valid"
            If(Compare(Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position), <, 5));
                Call Subroutine(initiateIndicatorSlam);
            End;
        Else;
            Call Subroutine(initiateGroundSlam);
        End;
        If(Compare((Event Player).is_using_slam, ==, True));
            Wait Until(Not(Is Using Ability 1(Event Player)), 9999);
            Set Player Variable(Event Player, is_using_slam, False);
            Set Ability Cooldown(Event Player, Button(Ability 1), 6);
        End;
    }
}

rule ("[doomfist.opy]: InitiateGroundSlam()") {
    event {
        Subroutine;
        initiateGroundSlam;
    }
    actions {
        Set Player Variable(Event Player, is_using_slam, True);
        Set Gravity(Event Player, 0);
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Call Subroutine(startSlamAnimation);
        "apply custom momentum"
        Apply Impulse(Event Player, Add(Normalize(Multiply(Facing Direction Of(Event Player), Add(Forward, Left))), Vector(0, 0.075, 0)), 16, To World, Incorporate Contrary Motion);
        Wait(0.3, Ignore Condition);
        Set Gravity(Event Player, 100);
        Wait Until(Or(Is On Ground(Event Player), Not(Is Using Ability 1(Event Player))), 9999);
        Stop Forcing Throttle(Event Player);
    }
}

rule ("[doomfist.opy]: InitiateIndicatorSlam()") {
    event {
        Subroutine;
        initiateIndicatorSlam;
    }
    actions {
        Stop Chasing Player Variable(Event Player, proto_indicator_slam_position);
        Stop Chasing Player Variable(Event Player, indicator_slam_position);
        Set Player Variable(Event Player, proto_indicator_slam_position, Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(15, Facing Direction Of(Event Player))), Null, Null, First Of(Null)));
        Set Player Variable(Event Player, indicator_slam_position, Ray Cast Hit Position((Event Player).proto_indicator_slam_position, Add((Event Player).proto_indicator_slam_position, Multiply(5, Down)), Null, All Players(All Teams), False));
        Set Player Variable(Event Player, indicator_slam_direction, Direction Towards(Position Of(Event Player), (Event Player).indicator_slam_position));
        Set Player Variable(Event Player, is_using_slam, True);
        Set Gravity(Event Player, 0.001);
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Call Subroutine(startSlamAnimation);
        Set Player Variable(Event Player, current_position, Position Of(Event Player));
        Chase Player Variable At Rate(Event Player, current_position, (Event Player).indicator_slam_position, 25, None);
        Start Forcing Player Position(Event Player, (Event Player).current_position, True);
        "Helps prevent clipping through map geometry"
        Apply Impulse(Event Player, (Event Player).indicator_slam_direction, 25, To World, Cancel Contrary Motion XYZ);
        Wait Until(Or(Compare(Distance Between((Event Player).current_position, (Event Player).indicator_slam_position), <=, 0.01), Not(Is Using Ability 1(Event Player))), 9999);
        Stop Forcing Player Position(Event Player);
        Stop Chasing Player Variable(Event Player, current_position);
        Stop Forcing Throttle(Event Player);
        Set Gravity(Event Player, 100);
        "cancel current momentum"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
    }
}

rule ("[doomfist.opy]: startSlamAnimation()") {
    event {
        Subroutine;
        startSlamAnimation;
    }
    actions {
        "Start slam animation"
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        Allow Button(Event Player, Button(Ability 1));
        Set Player Variable(Event Player, shift_pressed_by_bot, True);
        Press Button(Event Player, Button(Ability 1));
        Set Player Variable(Event Player, shift_pressed_by_bot, False);
        Disallow Button(Event Player, Button(Ability 1));
        Wait(0.016, Ignore Condition);
        "Cancel current momentum"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
    }
}

rule ("[doomfist.opy]: Calculate slam damage based on air time") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_slam == True;
    }
    actions {
        Set Player Variable(Event Player, slam_damage, 0);
        Wait Until(Update Every Frame(Not(Is On Ground(Event Player))), 9999);
        Call Subroutine(createSlamDamageGui);
        Chase Player Variable At Rate(Event Player, slam_damage, 125, 100, None);
        Wait Until(Update Every Frame(Is On Ground(Event Player)), 9999);
        Stop Chasing Player Variable(Event Player, slam_damage);
        Wait(1, Ignore Condition);
        Call Subroutine(destroySlamDamageGui);
    }
}

rule ("[doomfist.opy]: createSlamDamageGui()") {
    event {
        Subroutine;
        createSlamDamageGui;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).slam_damage, Down), Null, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.2, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, slam_damage_text_entity, Last Text ID);
    }
}

rule ("[doomfist.opy]: destroySlamDamageGui()") {
    event {
        Subroutine;
        destroySlamDamageGui;
    }
    actions {
        Destroy In-World Text((Event Player).slam_damage_text_entity);
        Set Player Variable(Event Player, slam_damage_text_entity, Null);
    }
}

rule ("[doomfist.opy]: Remove OW2 slam damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        "Ability used to damage player is Seismic Slam"
        Event Ability == Button(Ability 1);
    }
    actions {
        Heal(Victim, Null, Event Damage);
    }
}

rule ("[doomfist.opy]: Find slammed victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        "Ability used to damage player is Seismic Slam"
        Event Ability == Button(Ability 1);
        1 <= Distance Between(Attacker, Victim);
        Distance Between(Attacker, Victim) <= 8;
    }
    actions {
        "TODO add condition to check victim in 60 degree cone"
        Modify Player Variable(Attacker, slammed_victims, Append To Array, Victim);
    }
}

rule ("[doomfist.opy]: Slammed victims damage and pull/push effects") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        "Ability used to damage player is Seismic Slam"
        Event Ability == Button(Ability 1);
        Array Contains((Attacker).slammed_victims, Victim) == True;
    }
    actions {
        "Custom slam damage"
        Damage(Victim, Attacker, Round To Integer((Attacker).slam_damage, Down));
        Set Gravity(Victim, 50);
        "Boop slammed victims up"
        Apply Impulse(Victim, Up, 5.25, To World, Cancel Contrary Motion XYZ);
        "Push/Pull slammed victims; multiply pull magnitude by 1.5 to counteract air resistance"
        Apply Impulse(Victim, Direction Towards(Victim, Attacker), Multiply(1.5, Subtract(Distance Between(Victim, Attacker), 4)), To World, Cancel Contrary Motion XYZ);
        Set Gravity(Victim, 100);
    }
}

rule ("[doomfist.opy]: Slam indicator VFX") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).slam_to_use == 1;
        Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
        Is Using Ability 1(Event Player) == False;
        Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position) < 5;
    }
    actions {
        Call Subroutine(createSlamIndicatorGui);
        Wait Until(Or(Or(Or(Compare((Event Player).slam_to_use, !=, 1), Compare(Ability Cooldown(Event Player, Button(Ability 1)), >, 0)), Is Using Ability 1(Event Player)), Compare(Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position), >=, 5)), 9999);
        Call Subroutine(destroySlamIndicatorGui);
    }
}

rule ("[doomfist.opy]: createSlamIndicatorGui()") {
    event {
        Subroutine;
        createSlamIndicatorGui;
    }
    actions {
        For Global Variable(i, 0, 2, 1);
            Create Beam Effect(If-Then-Else(And(And(And(Compare((Event Player).slam_to_use, ==, 1), Compare(Ability Cooldown(Event Player, Button(Ability 1)), <=, 0)), Not(Is Using Ability 1(Event Player))), Compare(Distance Between((Event Player).indicator_slam_position, (Event Player).proto_indicator_slam_position), <, 5)), Event Player, Null), Good Beam, Update Every Frame(Add((Event Player).indicator_slam_position, World Vector Of(Add(Multiply(Cosine From Degrees(Subtract(30, Multiply(Evaluate Once(Global.i), 60))), Forward), Multiply(Sine From Degrees(Subtract(30, Multiply(Evaluate Once(Global.i), 60))), Left)), Event Player, Rotation))), Update Every Frame(Add((Event Player).indicator_slam_position, Multiply(8, World Vector Of(Add(Multiply(Cosine From Degrees(Subtract(30, Multiply(Evaluate Once(Global.i), 60))), Forward), Multiply(Sine From Degrees(Subtract(30, Multiply(Evaluate Once(Global.i), 60))), Left)), Event Player, Rotation)))), Color(Blue), Visible To Position and Radius);
            Modify Player Variable(Event Player, indicator_entity, Append To Array, Last Created Entity);
        End;
    }
}

rule ("[doomfist.opy]: destroySlamIndicatorGui()") {
    event {
        Subroutine;
        destroySlamIndicatorGui;
    }
    actions {
        For Global Variable(i, 0, Count Of((Event Player).indicator_entity), 1);
            Destroy Effect(Value In Array((Event Player).indicator_entity, Global.i));
        End;
        Set Player Variable(Event Player, indicator_entity, Empty Array);
    }
}

rule ("[doomfist.opy]: Initialize rocket punch") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions {
        Set Player Variable(Event Player, punched_victims, Empty Array);
        Set Player Variable(Event Player, wall_impacted_victims, Empty Array);
        Set Player Variable(Event Player, punch_charge_time, 0);
        Chase Player Variable At Rate(Event Player, punch_charge_time, 1.4, 1, None);
        Wait Until(Not(Is Button Held(Event Player, Button(Secondary Fire))), 9999);
        Stop Chasing Player Variable(Event Player, punch_charge_time);
    }
}

rule ("[doomfist.opy]: Find wall impacted victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Attacker).punched_victims, Victim) == True;
        Array Contains((Attacker).wall_impacted_victims, Victim) == False;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Add(Multiply(82.78145695364239, Subtract((Event Player).punch_charge_time, 1.4)), 150), Event Damage));
        Modify Player Variable(Attacker, wall_impacted_victims, Append To Array, Victim);
    }
}

rule ("[doomfist.opy]: Find punched victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Attacker).punched_victims, Victim) == False;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Add(Multiply(41.390728476821195, Subtract((Event Player).punch_charge_time, 1.4)), 100), Event Damage));
        Modify Player Variable(Attacker, punched_victims, Append To Array, Victim);
    }
}

rule ("[doomfist.opy]: Remove Empowered Punch from ultimate") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        "eventPlayer.disallowButton(Button.ABILITY_1)\r\n eventPlayer.disallowButton(Button.ABILITY_2)"
        Wait Until(Is Button Held(Event Player, Button(Primary Fire)), 4.8);
        Wait Until(Not(Is Using Ultimate(Event Player)), 9999);
        Start Holding Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Set Status(Event Player, Null, Stunned, 0.016);
        Stop Holding Button(Event Player, Button(Secondary Fire));
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
        Set Secondary Fire Enabled(Event Player, False);
        Wait(0.016, Ignore Condition);
        Set Secondary Fire Enabled(Event Player, True);
        "eventPlayer.allowButton(Button.ABILITY_1)\r\n eventPlayer.allowButton(Button.ABILITY_2)"
        Allow Button(Event Player, Button(Secondary Fire));
    }
}

rule ("[doomfist.opy]: Deal OW1 Meteor Strike damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Ultimate);
        Event Damage < 200;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Add(200, Multiply(2.176470588235294, Subtract(Event Damage, 100))), Event Damage));
    }
}

rule ("[doomfist.opy]: Deal OW1 hand cannon damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        "Deal additional damage to match OW1 damage"
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.2), Event Damage));
    }
}

rule ("[dva.opy]: Initialize Dva") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initDva);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[dva.opy]: initDva()") {
    event {
        Subroutine;
        initDva;
    }
    actions {
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, health_normal, 300);
        Set Player Variable(Event Player, health_armor, 300);
        Set Player Variable(Event Player, health_shields, 0);
        Call Subroutine(applyCustomHealth);
        Wait(1, Ignore Condition);
        Loop If(Compare(Max Health(Event Player), !=, 600));
        Wait Until(Not(Is In Alternate Form(Event Player)), 9999);
        Set Ultimate Charge(Event Player, 0);
    }
}

rule ("[dva.opy]: Set default booster cooldown") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 9999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 4);
    }
}

rule ("[dva.opy]: Set default missile cooldown") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 9999);
        Set Ability Cooldown(Event Player, Button(Ability 2), 8);
    }
}

rule ("[dva.opy]: Decouple melee button from activating melee animation during booster") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Melee));
        Wait Until(Not(Is Using Ability 1(Event Player)), 9999);
        Allow Button(Event Player, Button(Melee));
    }
}

rule ("[dva.opy]: Cancel booster if melee pressed") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Button Held(Event Player, Button(Melee)) == True;
    }
    actions {
        Press Button(Event Player, Button(Ability 1));
        Allow Button(Event Player, Button(Melee));
        Press Button(Event Player, Button(Melee));
        Disallow Button(Event Player, Button(Melee));
    }
}

rule ("[echo.opy]: Tank armor, shields and health for every tank") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(D.Va)), Array(300, 300, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Wrecking Ball)), Array(500, 100, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Orisa)), Array(200, 250, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Reinhardt)), Array(300, 200, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Roadhog)), Array(600, 0, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Sigma)), Array(300, 0, 100));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Winston)), Array(350, 150, 0));
        Set Global Variable At Index(health_pool, Index Of Array Value(All Heroes, Hero(Zarya)), Array(200, 0, 200));
    }
}

rule ("[echo.opy]: Initialize Echo") {
    event {
        Ongoing - Each Player;
        All;
        Echo;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initEcho);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[echo.opy]: Deal OW1 echo focusing beam under 50% hp") {
    event {
        Player Dealt Damage;
        All;
        Echo;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
        Divide(Multiply(100, Health(Victim)), Max Health(Victim)) < 50;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.142857142857142), Event Damage));
    }
}

rule ("[echo.opy]: Set Life for echo when duplicating a tank") {
    event {
        Ongoing - Each Player;
        All;
        Echo;
    }
    conditions {
        Is Duplicating(Event Player) == True;
        Array Contains(All Tank Heroes, Hero Being Duplicated(Event Player)) == True;
        Hero Being Duplicated(Event Player) != Hero(Doomfist);
    }
    actions {
        Set Player Variable(Event Player, hero_id_duplicated, Index Of Array Value(All Heroes, Hero Being Duplicated(Event Player)));
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, health_normal, First Of(Value In Array(Global.health_pool, (Event Player).hero_id_duplicated)));
        Set Player Variable(Event Player, health_armor, Value In Array(Value In Array(Global.health_pool, (Event Player).hero_id_duplicated), 1));
        Set Player Variable(Event Player, health_shields, Value In Array(Value In Array(Global.health_pool, (Event Player).hero_id_duplicated), 2));
        Call Subroutine(applyCustomHealth);
    }
}

rule ("[genji.opy]: Initialize Genji") {
    event {
        Ongoing - Each Player;
        All;
        Genji;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initGenji);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[genji.opy]: initGenji()") {
    event {
        Subroutine;
        initGenji;
    }
    actions {
        Set Ammo(Event Player, 0, 30);
        Set Max Ammo(Event Player, 0, 30);
    }
}

rule ("[genji.opy]: Deal OW1 shuriken damage") {
    event {
        Player Dealt Damage;
        All;
        Genji;
    }
    conditions {
        Or(Compare(Event Ability, ==, Button(Primary Fire)), Compare(Event Ability, ==, Button(Secondary Fire))) == True;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.074074074074074), Event Damage));
    }
}

rule ("[hanzo.opy]: Initialize Hanzo") {
    event {
        Ongoing - Each Player;
        All;
        Hanzo;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initHanzo);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[hanzo.opy]: Deal OW1 primary fire damage") {
    event {
        Player Dealt Damage;
        All;
        Hanzo;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.041666666666666), Event Damage));
    }
}

rule ("[hanzo.opy]: Deal OW1 storm arrow damage") {
    event {
        Player Dealt Damage;
        All;
        Hanzo;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.076923076923076), Event Damage));
    }
}

rule ("[illari.opy]: Initialize Illari") {
    event {
        Ongoing - Each Player;
        All;
        Illari;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initIllari);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[illari.opy]: Allow self healing during Pylon") {
    event {
        Ongoing - Each Player;
        All;
        Illari;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ability 2(Event Player)), 9999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[junkerqueen.opy]: Initialize Junkerqueen") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initJunkerqueen);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[junkrat.opy]: Initialize Junkrat") {
    event {
        Ongoing - Each Player;
        All;
        Junkrat;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initJunkrat);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[junkrat.opy]: initJunkrat()") {
    event {
        Subroutine;
        initJunkrat;
    }
    actions {
        "Reduce damage to the trap"
        Set Damage Dealt(Event Player, 80);
    }
}

rule ("[junkrat.opy]: Deal extra damage on ability other than steel trap and increase root duration.") {
    event {
        Player Dealt Damage;
        All;
        Junkrat;
    }
    actions {
        If(Compare(Event Ability, ==, Button(Ability 1)));
            "Increase damage for concussion mine"
            Damage(Victim, Attacker, Subtract(Add(Multiply(Add(Event Damage, Multiply(Divide(Subtract(Event Damage, 30), 80), 10)), 1.25), 1), Event Damage));
        Else If(Compare(Event Ability, !=, Button(Ability 2)));
            "Increase damage for every ability except trap and conccusion mine"
            Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.25), Event Damage));
        Else;
            "Increase root duration"
            Set Status(Victim, Attacker, Rooted, 3);
    }
}

rule ("[kiriko.opy]: Initialize Kiriko") {
    event {
        Ongoing - Each Player;
        All;
        Kiriko;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initKiriko);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[kiriko.opy]: initKiriko()") {
    event {
        Subroutine;
        initKiriko;
    }
    actions {
        Call Subroutine(removeSelfHealing);
    }
}

rule ("[kiriko.opy]: Allow self healing during Suzu") {
    event {
        Ongoing - Each Player;
        All;
        Kiriko;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ability 2(Event Player)), 9999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[lifeweaver.opy]: Initialize Lifeweaver") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initLifeweaver);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[lifeweaver.opy]: initLifeweaver()") {
    event {
        Subroutine;
        initLifeweaver;
    }
    actions {
        Call Subroutine(removeSelfHealing);
    }
}

rule ("[lifeweaver.opy]: Allow self healing during Rejuvanating Dash") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        "[TODO] Replace with better condition"
        Is Jumping(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        "[TODO] Replace with better condition"
        Wait Until(Not(Is Jumping(Event Player)), 9999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[lifeweaver.opy]: Allow self healing during Tree of Life") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ultimate(Event Player)), 9999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[lucio.opy]: Initialize Lucio") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initLucio);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[lucio.opy]: initLucio()") {
    event {
        Subroutine;
        initLucio;
    }
    actions {
        Call Subroutine(removeSelfHealing);
    }
}

rule ("[lucio.opy]: Handle lucio self healing while amp is not active and supp passive is active") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 2(Event Player) == False;
        Is Using Ability 1(Event Player) == False;
        (Event Player).support_passive_active != False;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 48);
    }
}

rule ("[lucio.opy]: Handle lucio self healing while amp is not active and support passive inactive") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 2(Event Player) == False;
        Is Using Ability 1(Event Player) == False;
        (Event Player).support_passive_active == False;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 120);
    }
}

rule ("[lucio.opy]: Handle lucio self when amp is active and supp passive is active") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
        Is Using Ability 1(Event Player) == False;
        (Event Player).support_passive_active != False;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 68.42105263157895);
    }
}

rule ("[lucio.opy]: Handle lucio self when amp is active and supp passive is inactive") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
        Is Using Ability 1(Event Player) == False;
        (Event Player).support_passive_active == False;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
    }
}

rule ("[lucio.opy]: If lucio uses speed aura remove self healing") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[mccree.opy]: Initialize Mccree") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initMccree);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[mccree.opy]: initMccree()") {
    event {
        Subroutine;
        initMccree;
    }
    actions {
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, health_normal, 225);
        Set Player Variable(Event Player, health_armor, 0);
        Set Player Variable(Event Player, health_shields, 0);
        Call Subroutine(applyCustomHealth);
        Wait(1, Ignore Condition);
        Loop If(Compare(Max Health(Event Player), !=, 225));
        Disallow Button(Event Player, Button(Ability 2));
    }
}

rule ("[mccree.opy]: Throw projectile when pressing e") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
        "Ensure Cassidy is not rolling"
        Is Using Ability 1(Event Player) == False;
        "Ensure Cassidy is not hacked"
        Has Status(Event Player, Hacked) == False;
        "Ensure Cassidy is not frozen"
        Has Status(Event Player, Frozen) == False;
        "Ensure Cassidy is not knocked down"
        Has Status(Event Player, Knocked Down) == False;
        "Ensure Cassidy is not asleep"
        Has Status(Event Player, Asleep) == False;
        "Ensure Cassidy is not stunned"
        Has Status(Event Player, Stunned) == False;
    }
    actions {
        Create Projectile(Orb Projectile, Event Player, Null, Null, To World, Damage, Opposite Team Of(Team Of(Event Player)), 25, 1, 3, Bad Explosion, Explosion Sound, 0, 30, 0.233333333333333, 0, 0, 1);
        Set Ability Cooldown(Event Player, Button(Ability 2), 10);
    }
}

rule ("[mccree.opy]: Stun flashed enemy") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Event Ability == 0;
        "This check is needed to ensure that the damage source is flashbang"
        Event Damage >= 15;
        Or(Compare(Hero Of(Attacker), ==, Hero(Cassidy)), Compare(Hero Of(Attacker), ==, Hero(Genji))) == True;
    }
    actions {
        Set Status(Victim, Event Player, Stunned, 0.8);
    }
}

rule ("[mccree.opy]: Remove damage reduction during roll") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Damage Received(Event Player, 200);
        Wait Until(Not(Is Using Ability 1(Event Player)), 9999);
        Set Damage Received(Event Player, 100);
    }
}

rule ("[mccree.opy]: Remove damage reduction during deadeye") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Received(Event Player, 166.66666666666666);
        Wait Until(Not(Is Using Ultimate(Event Player)), 9999);
        Set Damage Received(Event Player, 100);
    }
}

rule ("[mei.opy]: Initialize Mei") {
    event {
        Ongoing - Each Player;
        All;
        Mei;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initMei);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[mei.opy]: initMei()") {
    event {
        Subroutine;
        initMei;
    }
    actions {
        Set Ammo(Event Player, 0, 120);
        Set Max Ammo(Event Player, 0, 120);
    }
}

rule ("[mei.opy]: Track freezing on enemy") {
    event {
        Player Dealt Damage;
        All;
        Mei;
    }
    conditions {
        Event Ability == Button(Primary Fire);
        (Victim).freeze_progress < 100;
    }
    actions {
        Stop Chasing Player Variable(Victim, freeze_slow_linger_time);
        "victims started taking freeze damage"
        If(Compare((Victim).freeze_progress, ==, 0));
            Set Player Variable(Victim, freeze_progress, 20);
        Else;
            Modify Player Variable(Victim, freeze_progress, Add, 2.85);
        End;
        Set Player Variable(Victim, freeze_move_penalty, If-Then-Else(Compare((Victim).freeze_progress, <, 70), (Victim).freeze_progress, 70));
        "victim.setMoveSpeed(100-victim.freeze_move_penalty)"
        Set Player Variable(Victim, freeze_slow_linger_time, 0);
        Chase Player Variable At Rate(Victim, freeze_slow_linger_time, 1, 1, None);
    }
}

rule ("[mei.opy]: Freeze enemy") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        (Victim).freeze_progress >= 100;
    }
    actions {
        Set Status(Victim, Event Player, Frozen, 1.3);
        Wait Until(Not(Has Status(Victim, Frozen)), 9999);
        Call Subroutine(clearFreezeEffect);
    }
}

rule ("[mei.opy]: clear freeze after exceeding linger time") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).freeze_slow_linger_time >= 1;
    }
    actions {
        Call Subroutine(clearFreezeEffect);
    }
}

rule ("[mei.opy]: clearFreezeEffect()") {
    event {
        Subroutine;
        clearFreezeEffect;
    }
    actions {
        Stop Chasing Player Variable(Event Player, freeze_slow_linger_time);
        Set Move Speed(Event Player, 100);
        Set Player Variable(Event Player, freeze_progress, 0);
    }
}

rule ("[mercy.opy]: Initialize Mercy") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initMercy);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[mercy.opy]: initMercy()") {
    event {
        Subroutine;
        initMercy;
    }
    actions {
        Set Ammo(Event Player, 0, 20);
        Set Max Ammo(Event Player, 0, 20);
    }
}

rule ("[mercy.opy]: Change GA Cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Or(And(Is Using Ability 1(Event Player), Is Button Held(Event Player, Button(Jump))), And(And(Is Using Ability 1(Event Player), Is Button Held(Event Player, Button(Crouch))), Not(Is Using Ultimate(Event Player)))) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 9999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
    }
}

rule ("[moira.opy]: Initialize Moira") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initMoira);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[moira.opy]: initMoira()") {
    event {
        Subroutine;
        initMoira;
    }
    actions {
        Call Subroutine(removeSelfHealing);
    }
}

rule ("[moira.opy]: Deny fade during coalescence") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        Wait Until(Not(Is Using Ultimate(Event Player)), 9999);
        Set Ability 1 Enabled(Event Player, True);
    }
}

rule ("[moira.opy]: Allow self healing during Biotic Grasp") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Firing Secondary(Event Player)), 9999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[moira.opy]: Allow self healing during Biotic Orb") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
        Is Button Held(Event Player, Button(Primary Fire)) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait(7, Ignore Condition);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[moira.opy]: Allow self healing during Coalescence") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ultimate(Event Player)), 9999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[orisa.opy]: Initialize Orisa") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initOrisa);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[orisa.opy]: initOrisa()") {
    event {
        Subroutine;
        initOrisa;
    }
    actions {
        While(Compare(Max Health(Event Player), !=, 450));
            Call Subroutine(clearCustomHealth);
            Set Player Variable(Event Player, health_normal, 200);
            Set Player Variable(Event Player, health_armor, 250);
            Set Player Variable(Event Player, health_shields, 0);
            Call Subroutine(applyCustomHealth);
            Wait(1, Ignore Condition);
        End;
        "Disable OW2 Javelin"
        Disallow Button(Event Player, Button(Secondary Fire));
        "Disable OW2 Javelin Spin"
        Disallow Button(Event Player, Button(Ability 2));
        "Disable Terra Surge"
        Disallow Button(Event Player, Button(Ultimate));
        "Below variables are also declared and initialized in reset_hero.opy"
        Set Player Variable(All Players(Team Of(Event Player)), friendly_orisa_player, Event Player);
        Set Player Variable(All Players(Opposite Team Of(Team Of(Event Player))), enemy_orisa_player, Event Player);
        Call Subroutine(replanishAmmo);
        Set Max Ammo(Event Player, 0, (Event Player).current_ammo_count);
        Set Player Variable(Event Player, is_using_supercharger, False);
        Set Player Variable(Event Player, is_using_halt, False);
    }
}

rule ("[orisa.opy]: Trigger Supercharger start") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Ultimate)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is On Ground(Event Player) == True;
    }
    actions {
        "Destroy any existing Supercharger"
        Call Subroutine(endSupercharger);
        "Start supercharger"
        Call Subroutine(startSupercharger);
    }
}

rule ("[orisa.opy]: Trigger Supercharger end") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).orisa_supercharger_uptime >= 15;
    }
    actions {
        Call Subroutine(endSupercharger);
    }
}

rule ("[orisa.opy]: startSupercharger()") {
    event {
        Subroutine;
        startSupercharger;
    }
    actions {
        Set Ultimate Charge(Event Player, 0);
        Set Ultimate Ability Enabled(Event Player, False);
        Communicate(Event Player, Voice Line Up);
        "Supercharge GUI"
        Set Player Variable(Event Player, orisa_supercharger_position, Add(Position Of(Event Player), Multiply(0.5, Up)));
        Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).orisa_supercharger_position, 0.5, None);
        Set Player Variable(Event Player, orisa_supercharger_entity, Last Created Entity);
        "Supercharge Effect"
        Play Effect(All Players(All Teams), Good Explosion, Color(Green), (Event Player).orisa_supercharger_position, 3);
        Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Green), (Event Player).orisa_supercharger_position, 200);
        "Start supercharger timer"
        Set Player Variable(Event Player, orisa_supercharger_uptime, 0);
        Chase Player Variable At Rate(Event Player, orisa_supercharger_uptime, 15, 1, None);
        Set Player Variable(Event Player, is_using_supercharger, True);
    }
}

rule ("[orisa.opy]: endSupercharger()") {
    event {
        Subroutine;
        endSupercharger;
    }
    actions {
        Set Ultimate Ability Enabled(Event Player, True);
        Stop Chasing Player Variable(Event Player, orisa_supercharger_uptime);
        Destroy Effect((Event Player).orisa_supercharger_entity);
        Set Player Variable(All Players(Team Of(Event Player)), is_supercharged, False);
        Set Player Variable(Event Player, is_using_supercharger, False);
    }
}

rule ("[orisa.opy]: Supercharge teammates in supercharger range") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Alive(Event Player) == True;
        ((Event Player).friendly_orisa_player).is_using_supercharger == True;
        Distance Between(Event Player, ((Event Player).friendly_orisa_player).orisa_supercharger_position) <= 25;
        Is In Line of Sight(Event Player, ((Event Player).friendly_orisa_player).orisa_supercharger_position, Barriers Do Not Block LOS) == True;
    }
    actions {
        Set Player Variable(Event Player, is_supercharged, True);
    }
}

rule ("[orisa.opy]: De-supercharge teammates outside supercharger range") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_supercharged == True;
        ((Event Player).friendly_orisa_player).is_using_supercharger == True;
        And(Compare(Distance Between(Event Player, ((Event Player).friendly_orisa_player).orisa_supercharger_position), <=, 25), Is In Line of Sight(Event Player, ((Event Player).friendly_orisa_player).orisa_supercharger_position, Barriers Do Not Block LOS)) == False;
    }
    actions {
        Wait(1, Abort When False);
        Set Player Variable(Event Player, is_supercharged, False);
    }
}

rule ("[orisa.opy]: De-supercharge teammates when supercharger ends") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).is_using_supercharger == False;
    }
    actions {
        Set Player Variable(All Players(Team Of(Event Player)), is_supercharged, False);
    }
}

rule ("[orisa.opy]: De-supercharge teammates when they die") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Dead(Event Player) == True;
        (Event Player).is_supercharged == True;
    }
    actions {
        Set Player Variable(Event Player, is_supercharged, False);
    }
}

rule ("[orisa.opy]: Damage boost player when supercharged") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_supercharged == True;
    }
    actions {
        Create Beam Effect(All Players(All Teams), Good Beam, ((Event Player).friendly_orisa_player).orisa_supercharger_position, Position Of(Event Player), Color(Blue), Visible To Position and Radius);
        Set Player Variable(Event Player, orisa_beam_entity, Last Created Entity);
        Create Effect(Event Player, Energy Sound, Color(Green), Position Of(Event Player), 100, Position and Radius);
        Set Player Variable(Event Player, orisa_beam_sound_effect, Last Created Entity);
        Set Damage Dealt(Event Player, 150);
    }
}

rule ("[orisa.opy]: Revert damage boost if not supercharged") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_supercharged == False;
    }
    actions {
        Destroy Effect((Event Player).orisa_beam_entity);
        Destroy Effect((Event Player).orisa_beam_sound_effect);
        Set Damage Dealt(Event Player, 100);
    }
}

rule ("[orisa.opy]: Trigger Halt ability start") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions {
        Call Subroutine(shootHalt);
        "Make sure player releases right click"
        Wait Until(Not(Is Button Held(Event Player, Button(Secondary Fire))), 9999);
        "Detect halt pull activation on right click"
        Wait Until(Or(Is Button Held(Event Player, Button(Secondary Fire)), Compare((Event Player).halt_position, ==, (Event Player).halt_ending_position)), 9999);
        Call Subroutine(explodeHalt);
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 6);
    }
}

rule ("[orisa.opy]: Shoot Halt Orb") {
    event {
        Subroutine;
        shootHalt;
    }
    actions {
        "Start halt"
        Set Player Variable(Event Player, is_using_halt, True);
        "Halt orb visuals"
        Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).halt_position, 0.6, Visible To Position and Radius);
        Set Player Variable(Event Player, halt_entity1, Last Created Entity);
        Modify Player Variable(Event Player, entity_huds, Append To Array, (Event Player).halt_entity1);
        Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).halt_position, 0.3, Visible To Position and Radius);
        Set Player Variable(Event Player, halt_entity2, Last Created Entity);
        Modify Player Variable(Event Player, entity_huds, Append To Array, (Event Player).halt_entity2);
        "Halt orb sounds"
        Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Lime Green), Event Player, 100);
        "Calculate starting/ending positions"
        Set Player Variable(Event Player, halt_position, Eye Position(Event Player));
        Set Player Variable(Event Player, halt_ending_position, Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(1000, Facing Direction Of(Event Player))), Null, Null, True));
        Set Player Variable(All Players(Opposite Team Of(Team Of(Event Player))), is_snared, False);
        Wait(0.1, Ignore Condition);
        "Start flying halt orb"
        Chase Player Variable At Rate(Event Player, halt_position, (Event Player).halt_ending_position, 25, Destination and Rate);
    }
}

rule ("[orisa.opy]: Explode Halt Orb") {
    event {
        Subroutine;
        explodeHalt;
    }
    actions {
        Stop Chasing Player Variable(Event Player, halt_position);
        Wait(0.45, Ignore Condition);
        Set Player Variable(Players Within Radius((Event Player).halt_position, 5, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), is_snared, True);
        Set Environment Credit Player(Players Within Radius((Event Player).halt_position, 5, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Event Player);
        "Halt orb explosion sounds"
        Play Effect(All Players(All Teams), Explosion Sound, Color(Lime Green), Event Player, 100);
        "Clear visuals"
        Destroy Effect((Event Player).halt_entity1);
        Destroy Effect((Event Player).halt_entity2);
        Modify Player Variable(Event Player, entity_huds, Remove From Array By Value, (Event Player).halt_entity1);
        Modify Player Variable(Event Player, entity_huds, Remove From Array By Value, (Event Player).halt_entity2);
        Set Player Variable(Event Player, is_using_halt, False);
    }
}

rule ("[orirsa.opy]: Slow down snared enemies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_snared == True;
    }
    actions {
        Set Move Speed(Event Player, 33);
        Wait(0.65, Ignore Condition);
        Set Move Speed(Event Player, 100);
    }
}

rule ("[orisa.opy]: Pull halted victims") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).is_snared == True;
    }
    actions {
        Set Player Variable(Event Player, position, Position Of(Event Player));
        Start Forcing Player Position(Event Player, (Event Player).position, True);
        Chase Player Variable At Rate(Event Player, position, ((Event Player).enemy_orisa_player).halt_position, 20, Destination and Rate);
        Wait Until(Compare((Event Player).position, ==, ((Event Player).enemy_orisa_player).halt_position), 9999);
        Stop Chasing Player Variable(Event Player, position);
        Stop Forcing Player Position(Event Player);
        "Cancel current momentum"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
        Set Player Variable(Event Player, is_snared, False);
    }
}

rule ("[orisa.opy]: Create Halt pull line vfx when in pull range") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        ((Event Player).enemy_orisa_player).is_using_halt == True;
        Distance Between(Event Player, ((Event Player).enemy_orisa_player).halt_position) <= 5;
        Is In Line of Sight(Event Player, ((Event Player).enemy_orisa_player).halt_position, All Barriers Block LOS) == True;
    }
    actions {
        "Halt orb explosion sounds"
        Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Lime Green), Event Player, 100);
        Create Beam Effect(All Players(All Teams), Good Beam, ((Event Player).enemy_orisa_player).halt_position, Event Player, If-Then-Else((Event Player).is_snared, Color(Green), Color(White)), Position Radius and Color);
        Set Player Variable(Event Player, halt_pull_line_entity, Last Created Entity);
        Modify Player Variable(Event Player, entity_huds, Append To Array, (Event Player).halt_pull_line_entity);
    }
}

rule ("[orisa.opy]: Destroy Halt pull line vfx when not in pull range") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        ((Event Player).enemy_orisa_player).is_using_halt == True;
        And(Compare(Distance Between(Event Player, ((Event Player).enemy_orisa_player).halt_position), <=, 5), Is In Line of Sight(Event Player, ((Event Player).enemy_orisa_player).halt_position, All Barriers Block LOS)) == False;
    }
    actions {
        Destroy Effect((Event Player).halt_pull_line_entity);
        Modify Player Variable(Event Player, entity_huds, Remove From Array By Value, (Event Player).halt_pull_line_entity);
    }
}

rule ("[orisa.opy]: Destroy Halt pull line vfx when halt is over") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        ((Event Player).enemy_orisa_player).is_using_halt == False;
    }
    actions {
        Destroy Effect((Event Player).halt_pull_line_entity);
        Modify Player Variable(Event Player, entity_huds, Remove From Array By Value, (Event Player).halt_pull_line_entity);
    }
}

rule ("[orisa.opy]: Trigger Projectile Barrier ability") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Button Held(Event Player, Button(Ability 2)) == True;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Ability 2), 10);
        Call Subroutine(throwBarrier);
        Call Subroutine(destroyBarrier);
        Call Subroutine(deployBarrier);
    }
}

rule ("[orisa.opy]: throwBarrier()") {
    event {
        Subroutine;
        throwBarrier;
    }
    actions {
        "Initialize barrier projectile"
        Set Player Variable(Event Player, barrier_orientation, Normalize(Multiply(Facing Direction Of(Event Player), Add(Forward, Left))));
        Set Player Variable(Event Player, barrier_proj_v0, Multiply(25, Facing Direction Of(Event Player)));
        Set Player Variable(Event Player, barrier_proj_p0, Eye Position(Event Player));
        Set Player Variable(Event Player, barrier_proj_t, 0);
        Chase Player Variable At Rate(Event Player, barrier_proj_t, 10, 1, Destination and Rate);
        Set Player Variable(Event Player, barrier_proj_velocity, (Event Player).barrier_proj_v0);
        Chase Player Variable At Rate(Event Player, barrier_proj_velocity, Vector(X Component Of((Event Player).barrier_proj_v0), Add(Multiply(-9.8, (Event Player).barrier_proj_t), Y Component Of((Event Player).barrier_proj_v0)), Z Component Of((Event Player).barrier_proj_v0)), 9999, Destination and Rate);
        Set Player Variable(Event Player, barrier_proj_position, (Event Player).barrier_proj_p0);
        Chase Player Variable At Rate(Event Player, barrier_proj_position, Vector(Add(Multiply(X Component Of((Event Player).barrier_proj_v0), (Event Player).barrier_proj_t), X Component Of((Event Player).barrier_proj_p0)), Add(Add(Multiply(-4.9, Raise To Power((Event Player).barrier_proj_t, 2)), Multiply(Y Component Of((Event Player).barrier_proj_v0), (Event Player).barrier_proj_t)), Y Component Of((Event Player).barrier_proj_p0)), Add(Multiply(Z Component Of((Event Player).barrier_proj_v0), (Event Player).barrier_proj_t), Z Component Of((Event Player).barrier_proj_p0))), 9999, Destination and Rate);
        "Draw barrier projectile object"
        Create Effect(All Players(All Teams), Sphere, Color(Lime Green), (Event Player).barrier_proj_position, 0.1, Position and Radius);
        Set Player Variable(Event Player, barrier_projectile, Last Created Entity);
        "Wait for barrier projectile to land"
        Wait Until(Update Every Frame(Compare(Distance Between((Event Player).barrier_proj_position, Ray Cast Hit Position((Event Player).barrier_proj_position, Add((Event Player).barrier_proj_position, (Event Player).barrier_proj_velocity), Null, Null, False)), <, 0.5)), 10);
        "Freeze barrier projectile"
        Stop Chasing Player Variable(Event Player, barrier_proj_t);
        Stop Chasing Player Variable(Event Player, barrier_proj_velocity);
        Stop Chasing Player Variable(Event Player, barrier_proj_position);
        "Move projectile to where it collided with the ground"
        Set Player Variable(Event Player, barrier_proj_position, Ray Cast Hit Position((Event Player).barrier_proj_position, Add((Event Player).barrier_proj_position, (Event Player).barrier_proj_velocity), Null, Null, False));
        "Destroy projectile"
        Destroy Effect((Event Player).barrier_projectile);
    }
}

rule ("[orisa.opy]: deployBarrier()") {
    event {
        Subroutine;
        deployBarrier;
    }
    actions {
        "Define barrer by the sphere center position"
        Set Player Variable(Event Player, barrier_position, Subtract((Event Player).barrier_proj_position, Multiply(3.5, (Event Player).barrier_orientation)));
        "Debug barrier center\r\n createEffect(eventPlayer, Effect.SPHERE, Color.BLACK, eventPlayer.barrier_position, 0.5, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)"
        Call Subroutine(fibonacciSphere);
        "Draw each barrier sample"
        For Global Variable(i, 0, Count Of((Event Player).barrier_entity_positions), 1);
            Set Player Variable(Event Player, barrier_sample_point, Value In Array((Event Player).barrier_entity_positions, Global.i));
            Create Effect(All Players(All Teams), Sphere, Team Of(Event Player), Evaluate Once((Event Player).barrier_sample_point), 0.295803989154980, None);
            Modify Player Variable(Event Player, barrier_entities, Append To Array, Last Created Entity);
        End;
        Set Player Variable(Event Player, barrier_active, True);
        Set Player Variable(Event Player, barrier_health, 600);
        Set Player Variable(Event Player, barrier_uptime, 0);
        Chase Player Variable At Rate(Event Player, barrier_uptime, 20, 1, None);
    }
}

rule ("[orisa.opy]: fibonacciSphere()") {
    event {
        Subroutine;
        fibonacciSphere;
    }
    actions {
        "Evenly distribute N points around a sphere\r\n Store coodrindate of those points to barrier_entity_positions array\r\n See https://stackoverflow.com/a/26127012 for algorithm"
        Set Player Variable(Event Player, barrier_entity_positions, Empty Array);
        For Global Variable(i, 0, 140, 1);
            Set Player Variable(Event Player, barrier_sample_y, Subtract(1, Multiply(Divide(Global.i, 139), 2)));
            "Do not draw bottom half of sphere"
            If(Compare((Event Player).barrier_sample_y, <, -0.2));
                Break;
            End;
            Set Player Variable(Event Player, barrier_sample_radius, Square Root(Subtract(1, Multiply((Event Player).barrier_sample_y, (Event Player).barrier_sample_y))));
            Set Player Variable(Event Player, barrier_sample_theta, Multiply(Global.PHI, Global.i));
            Set Player Variable(Event Player, barrier_sample_x, Multiply(Cosine From Radians((Event Player).barrier_sample_theta), (Event Player).barrier_sample_radius));
            Set Player Variable(Event Player, barrier_sample_z, Multiply(Sine From Radians((Event Player).barrier_sample_theta), (Event Player).barrier_sample_radius));
            Set Player Variable(Event Player, barrier_sample_point, Vector((Event Player).barrier_sample_x, (Event Player).barrier_sample_y, (Event Player).barrier_sample_z));
            Skip If(Compare(Angle Between Vectors((Event Player).barrier_sample_point, (Event Player).barrier_orientation), >, 90), 1);
            Modify Player Variable(Event Player, barrier_entity_positions, Append To Array, Add(Multiply(3.5, (Event Player).barrier_sample_point), (Event Player).barrier_position));
            //__label_continue_2__:
        End;
    }
}

rule ("[orisa.opy]: destroyBarrier()") {
    event {
        Subroutine;
        destroyBarrier;
    }
    actions {
        For Global Variable(i, 0, Count Of((Event Player).barrier_entities), 1);
            Destroy Effect(Value In Array((Event Player).barrier_entities, Global.i));
        End;
        Set Player Variable(Event Player, barrier_entities, Empty Array);
        Set Player Variable(Event Player, barrier_entity_positions, Empty Array);
        Set Player Variable(Event Player, barrier_active, False);
    }
}

rule ("[orisa.opy]: destroy barrier on hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_switched == True;
        Hero Of(Event Player) != Hero(Orisa);
    }
    actions {
        Call Subroutine(destroyBarrier);
    }
}

rule ("[orisa.opy]: Destroy barrier on barrier timeout") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).barrier_uptime >= 20;
    }
    actions {
        Stop Chasing Player Variable(Event Player, barrier_uptime);
        Call Subroutine(destroyBarrier);
    }
}

rule ("[orisa.opy]: Destroy barrier when barrier hp runs out") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).barrier_health <= 0;
    }
    actions {
        Stop Chasing Player Variable(Event Player, barrier_uptime);
        Call Subroutine(destroyBarrier);
    }
}

rule ("[orisa.opy]: Take no damage when behind barrier") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        ((Victim).friendly_orisa_player).barrier_active == True;
        Multiply(Distance Between(Eye Position(Attacker), ((Victim).friendly_orisa_player).barrier_position), Sine From Degrees(Angle Between Vectors(Facing Direction Of(Attacker), Direction Towards(Eye Position(Attacker), ((Victim).friendly_orisa_player).barrier_position)))) <= 3.5;
    }
    actions {
        Set Player Variable(Event Player, lsi_o, Eye Position(Attacker));
        Set Player Variable(Event Player, lsi_u, Direction Towards(Attacker, Victim));
        Set Player Variable(Event Player, lsi_c, ((Victim).friendly_orisa_player).barrier_position);
        Set Player Variable(Event Player, lsi_r, 3.5);
        Call Subroutine(findLineSphereIntersection);
        Set Player Variable(Event Player, orisa_barrier_hit_positions, Filtered Array((Event Player).lsi_x, And(And(Compare(Distance Between(((Victim).friendly_orisa_player).barrier_position, Current Array Element), <=, 3.5), Compare(Angle Between Vectors(Up, Direction Towards(((Victim).friendly_orisa_player).barrier_position, Current Array Element)), <=, 90)), Compare(Angle Between Vectors(((Victim).friendly_orisa_player).barrier_orientation, Direction Towards(((Victim).friendly_orisa_player).barrier_position, Current Array Element)), <=, 90))));
        For Global Variable(i, 0, Count Of((Event Player).orisa_barrier_hit_positions), 1);
            "barrier hit is between the attacker and the victim"
            If(Compare(Distance Between(Eye Position(Attacker), Value In Array((Event Player).orisa_barrier_hit_positions, Global.i)), <, Distance Between(Eye Position(Attacker), Eye Position(Victim))));
                Heal(Victim, Null, Event Damage);
                Modify Player Variable((Victim).friendly_orisa_player, barrier_health, Subtract, Event Damage);
                Abort;
            End;
        End;
    }
}

rule ("[orisa.opy]: Receive no healing when behind barrier") {
    event {
        Player Received Healing;
        All;
        All;
    }
    conditions {
        ((Healee).enemy_orisa_player).barrier_active == True;
        Multiply(Distance Between(Eye Position(Healer), ((Healee).enemy_orisa_player).barrier_position), Sine From Degrees(Angle Between Vectors(Direction Towards(Healer, Healee), Direction Towards(Eye Position(Healer), ((Healee).enemy_orisa_player).barrier_position)))) <= 3.5;
    }
    actions {
        Set Player Variable(Event Player, lsi_o, Eye Position(Healer));
        Set Player Variable(Event Player, lsi_u, Direction Towards(Healer, Healee));
        Set Player Variable(Event Player, lsi_c, ((Healee).enemy_orisa_player).barrier_position);
        Set Player Variable(Event Player, lsi_r, 3.5);
        Call Subroutine(findLineSphereIntersection);
        Set Player Variable(Event Player, orisa_barrier_hit_positions, Filtered Array((Event Player).lsi_x, And(And(Compare(Distance Between(((Healee).enemy_orisa_player).barrier_position, Current Array Element), <=, 3.5), Compare(Angle Between Vectors(Up, Direction Towards(((Healee).enemy_orisa_player).barrier_position, Current Array Element)), <=, 90)), Compare(Angle Between Vectors(((Healee).enemy_orisa_player).barrier_orientation, Direction Towards(((Healee).enemy_orisa_player).barrier_position, Current Array Element)), <=, 90))));
        For Global Variable(i, 0, Count Of((Event Player).orisa_barrier_hit_positions), 1);
            "barrier hit is between the healer and the healee"
            If(Compare(Distance Between(Eye Position(Healer), Value In Array((Event Player).orisa_barrier_hit_positions, Global.i)), <, Distance Between(Eye Position(Healer), Eye Position(Healee))));
                Damage(Healee, Null, Event Healing);
                Modify Player Variable((Healee).enemy_orisa_player, barrier_health, Subtract, Event Healing);
                Abort;
            End;
        End;
    }
}

rule ("[orisa.opy]: Save ammo count when finished firing") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Firing Primary(Event Player) == False;
    }
    actions {
        Set Player Variable(Event Player, current_ammo_count, Ammo(Event Player, 0));
    }
}

rule ("[orisa.opy]: Correct ammo count when wrong") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).current_ammo_count != Ammo(Event Player, 0);
    }
    actions {
        Set Ammo(Event Player, 0, (Event Player).current_ammo_count);
    }
}

rule ("[orisa.opy]: Replanish ammo on reload") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Reloading(Event Player) == True;
    }
    actions {
        Call Subroutine(replanishAmmo);
    }
}

rule ("[orisa.opy]: replanishAmmo()") {
    event {
        Subroutine;
        replanishAmmo;
    }
    actions {
        Set Player Variable(Event Player, current_ammo_count, 125);
        Set Ammo(Event Player, 0, (Event Player).current_ammo_count);
    }
}

rule ("[orisa.opy]: Remove overhealth during fortify") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Damage(Event Player, Null, 250);
    }
}

rule ("[ramattra.opy]: Initialize Ramattra") {
    event {
        Ongoing - Each Player;
        All;
        Ramattra;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initRamattra);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[ramattra.opy]: initRamattra()") {
    event {
        Subroutine;
        initRamattra;
    }
    actions {
        While(Compare(Max Health(Event Player), !=, 400));
            Call Subroutine(clearCustomHealth);
            Set Player Variable(Event Player, health_normal, 400);
            Set Player Variable(Event Player, health_armor, 0);
            Set Player Variable(Event Player, health_shields, 0);
            Call Subroutine(applyCustomHealth);
            Wait(1, Ignore Condition);
        End;
    }
}

rule ("[reaper.opy]: Initialize Reaper") {
    event {
        Ongoing - Each Player;
        All;
        Reaper;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initReaper);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[reaper.opy]: Deal OW1 Reaper primary fire damage") {
    event {
        Player Dealt Damage;
        All;
        Reaper;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.111111111111111), Event Damage));
    }
}

rule ("[reinhardt.opy]: Initialize Reinhardt") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initReinhardt);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[reinhardt.opy]: initReinhardt()") {
    event {
        Subroutine;
        initReinhardt;
    }
    actions {
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, health_normal, 300);
        Set Player Variable(Event Player, health_armor, 200);
        Set Player Variable(Event Player, health_shields, 0);
        Call Subroutine(applyCustomHealth);
        Wait(1, Ignore Condition);
        Loop If(Compare(Max Health(Event Player), !=, 500));
    }
}

rule ("[reinhardt.opy]: Set default charge cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 9999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 10);
    }
}

rule ("[reinhardt.opy]: Force single firestrike") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 1);
        "Every time rein uses firestrike, reset the resource to 0"
        Set Ability Charge(Event Player, Button(Ability 2), 0);
        Wait(6, Ignore Condition);
        Set Ability Charge(Event Player, Button(Ability 2), 2);
    }
}

rule ("[reinhardt.opy]: Increase charge damage") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ability 1);
        "Checks for pin vs boop damage (+ 1 because apparently 50.0 > 50 == true for whatever reason)"
        Event Damage > 51;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.333333333333333), Event Damage));
    }
}

rule ("[reinhardt.opy]: OW1 one shot earthshatter") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ultimate);
        Event Damage > 85;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.470588235294117), Event Damage));
    }
}

rule ("[roadhog.opy]: Initialize Roadhog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initRoadhog);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[roadhog.opy]: initRoadhog()") {
    event {
        Subroutine;
        initRoadhog;
    }
    actions {
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, health_normal, 600);
        Set Player Variable(Event Player, health_armor, 0);
        Set Player Variable(Event Player, health_shields, 0);
        Call Subroutine(applyCustomHealth);
        Wait(1, Ignore Condition);
        Loop If(Compare(Max Health(Event Player), !=, 600));
        Set Ammo(Event Player, 0, 5);
        Set Max Ammo(Event Player, 0, 5);
        Set Damage Dealt(Event Player, 110);
    }
}

rule ("[roadhog.opy]: Set default hook cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, time_hook_was_active, 0);
        Chase Player Variable At Rate(Event Player, time_hook_was_active, 3, 1, None);
        Wait Until(Not(Is Using Ability 1(Event Player)), 99999);
        Set Ability Cooldown(Event Player, Button(Ability 1), Subtract(8, (Event Player).time_hook_was_active));
    }
}

rule ("[roadhog.opy]: Disable all abilities during ult") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Melee Enabled(Event Player, False);
        Set Ability 1 Enabled(Event Player, False);
        Set Ability 2 Enabled(Event Player, False);
        Wait Until(Not(Is Using Ultimate(Event Player)), 9999);
        Set Melee Enabled(Event Player, True);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability 2 Enabled(Event Player, True);
    }
}

rule ("[roadhog.opy]: Force autofire during ult") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Is Button Held(Event Player, Button(Primary Fire)) == False;
    }
    actions {
        Start Holding Button(Event Player, Button(Primary Fire));
    }
}

rule ("[roadhog.opy]: Stop autofire when not in ult") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}

rule ("[roadhog.opy]: Cancel ult when stunned") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Or(Or(Or(Or(Has Status(Event Player, Hacked), Has Status(Event Player, Frozen)), Has Status(Event Player, Knocked Down)), Has Status(Event Player, Asleep)), Has Status(Event Player, Stunned)) == True;
    }
    actions {
        If(Has Status(Event Player, Hacked));
        Else If(Has Status(Event Player, Frozen));
            Wait Until(Not(Has Status(Event Player, Frozen)), 9999);
        Else If(Has Status(Event Player, Knocked Down));
            Wait Until(Not(Has Status(Event Player, Knocked Down)), 9999);
        Else If(Has Status(Event Player, Asleep));
            Wait Until(Not(Has Status(Event Player, Asleep)), 9999);
        Else If(Has Status(Event Player, Stunned));
            Wait Until(Not(Has Status(Event Player, Stunned)), 9999);
        End;
        If(Is Using Ultimate(Event Player));
            Call Subroutine(respawnSameState);
    }
}

rule ("[roadhog.opy]: Move hooked enemies closer") {
    event {
        Player Dealt Damage;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 9999);
        If(Compare(Distance Between(Victim, Attacker), <=, 4.5));
            Teleport(Victim, Ray Cast Hit Position(Position Of(Attacker), Add(Position Of(Attacker), Multiply(3, Direction Towards(Attacker, Victim))), Null, Null, False));
    }
}

rule ("[roadhog.opy]: Reduce ultimate duration") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Wait(6, Ignore Condition);
        "Check if the ultimate was not cancelled before"
        If(Is Using Ultimate(Event Player));
            Call Subroutine(respawnSameState);
    }
}

rule ("[sigma.opy]: Initialize Sigma") {
    event {
        Ongoing - Each Player;
        All;
        Sigma;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initSigma);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[sigma.opy]: initSigma()") {
    event {
        Subroutine;
        initSigma;
    }
    actions {
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, health_normal, 300);
        Set Player Variable(Event Player, health_armor, 0);
        Set Player Variable(Event Player, health_shields, 100);
        Call Subroutine(applyCustomHealth);
        Wait(1, Ignore Condition);
        Loop If(Compare(Max Health(Event Player), !=, 400));
    }
}

rule ("[sigma.opy]: Change accretion damage") {
    event {
        Player Dealt Damage;
        All;
        Sigma;
    }
    conditions {
        Event Ability == Button(Ability 2);
        "Checks for direct hit vs splash damage"
        Event Damage > 40;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.375), Event Damage));
    }
}

rule ("[soldier.opy]: Initialize Soldier 76") {
    event {
        Ongoing - Each Player;
        All;
        Soldier: 76;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initSoldier);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[soldier.opy]: initSoldier()") {
    event {
        Subroutine;
        initSoldier;
    }
    actions {
        Set Healing Dealt(Event Player, 87.5);
    }
}

rule ("[soldier.opy]: Deal OW1 soldier primary fire damage") {
    event {
        Player Dealt Damage;
        All;
        Soldier: 76;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.052631578947368), Event Damage));
    }
}

rule ("[sombra.opy]: Initialize Sombra") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initSombra);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[sombra.opy]: initSombra()") {
    event {
        Subroutine;
        initSombra;
    }
    actions {
        Set Player Variable(All Players(Team Of(Event Player)), friendly_sombra_player, Event Player);
        Set Player Variable(All Players(Opposite Team Of(Team Of(Event Player))), enemy_sombra_player, Event Player);
    }
}

rule ("[sombra.opy]: Cancel invis if hack activated") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Press Button(Event Player, Button(Ability 1));
    }
}

rule ("[sombra.opy]: OW1 hack duration on enemies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Has Status(Event Player, Hacked) == True;
    }
    actions {
        Set Status(Event Player, Null, Hacked, 5);
    }
}

rule ("[sombra.opy]: No damage with EMP") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Ultimate Charge Percent(Event Player) >= 100;
    }
    actions {
        Wait Until(Is Button Held(Event Player, Button(Ultimate)), 9999);
        Wait Until(Compare(Ultimate Charge Percent(Event Player), <=, 0), 9999);
        Set Damage Dealt(Event Player, 0);
        Wait Until(Is Using Ultimate(Event Player), 9999);
        Set Damage Dealt(Event Player, 100);
    }
}

rule ("[sombra.opy]: Deal OW1 machine pistol damage") {
    event {
        Player Dealt Damage;
        All;
        Sombra;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.066666666666666), Event Damage));
    }
}

rule ("[sombra.opy]: Remove hack bonus damage") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Has Status(Event Player, Hacked) == True;
    }
    actions {
        Start Damage Modification(Event Player, (Event Player).enemy_sombra_player, 80, None);
        Set Player Variable(Event Player, hack_damage_modifier, Last Damage Modification ID);
        Wait Until(Not(Has Status(Event Player, Hacked)), 9999);
        Stop Damage Modification((Event Player).hack_damage_modifier);
    }
}

rule ("[sombra.opy]: Increase stealth movement speed") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Move Speed(Event Player, 103.125);
        Wait Until(Not(Is Using Ability 1(Event Player)), 9999);
        Set Move Speed(Event Player, 100);
    }
}

rule ("[sombra.opy]: Set default hack cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Secondary Fire)) >= 4;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 8);
    }
}

rule ("[symmetra.opy]: Initialize Symmetra") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initSymmetra);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[symmetra.opy]: initSymmetra()") {
    event {
        Subroutine;
        initSymmetra;
    }
    actions {
        Set Ammo(Event Player, 0, 70);
        Set Max Ammo(Event Player, 0, 70);
    }
}

rule ("[symmetra.opy]: Set OW1 Symmetra Photo Projector projectile speed") {
    event {
        Ongoing - Each Player;
        All;
        Symmetra;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Projectile Speed(Event Player, 50);
        Wait Until(Not(Is Firing Secondary(Event Player)), 9999);
        Set Projectile Speed(Event Player, 100);
    }
}

rule ("[torbjorn.opy]: Initialize Torbjorn") {
    event {
        Ongoing - Each Player;
        All;
        Torbjörn;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initTorbjorn);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[torbjorn.opy]: initTorbjorn()") {
    event {
        Subroutine;
        initTorbjorn;
    }
    actions {
        While(Compare(Max Health(Event Player), !=, 250));
            Call Subroutine(clearCustomHealth);
            Set Player Variable(Event Player, health_normal, 200);
            Set Player Variable(Event Player, health_armor, 50);
            Set Player Variable(Event Player, health_shields, 0);
            Call Subroutine(applyCustomHealth);
            Wait(1, Ignore Condition);
        End;
    }
}

rule ("[torbjorn.opy]: Correct overload hp") {
    event {
        Ongoing - Each Player;
        All;
        Torbjörn;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Damage(Event Player, Null, 11.111111111111114);
    }
}

rule ("[tracer.opy]: Initialize Tracer") {
    event {
        Ongoing - Each Player;
        All;
        Tracer;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initTracer);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[tracer.opy]: Deal OW1 tracer primary fire damage") {
    event {
        Player Dealt Damage;
        All;
        Tracer;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.090909090909090), Event Damage));
    }
}

rule ("[widowmaker.opy]: Initialize Widowmaker") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initWidowmaker);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[widowmaker.opy]: initWidowmaker()") {
    event {
        Subroutine;
        initWidowmaker;
    }
    actions {
        While(Compare(Max Health(Event Player), !=, 175));
            Call Subroutine(clearCustomHealth);
            Set Player Variable(Event Player, health_normal, 175);
            Set Player Variable(Event Player, health_armor, 0);
            Set Player Variable(Event Player, health_shields, 0);
            Call Subroutine(applyCustomHealth);
            Wait(1, Ignore Condition);
        End;
    }
}

rule ("[widowmaker.opy]: Revert sniper damage falloff") {
    event {
        Player Dealt Damage;
        All;
        Widowmaker;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Firing Primary(Event Player) == True;
        Event Ability == Button(Primary Fire);
    }
    actions {
        Set Player Variable(Event Player, scoped_shot_distance, Distance Between(Eye Position(Attacker), Victim));
        Set Player Variable(Event Player, ow2_scoped_damage_falloff_scalar, Add(Multiply(Divide(Subtract((Event Player).scoped_shot_distance, 40), 20), 0.5), Subtract(1, Divide(Subtract((Event Player).scoped_shot_distance, 40), 20))));
        "Cap min/max scalar\r\n Max damage scalar"
        If(Compare((Event Player).ow2_scoped_damage_falloff_scalar, >, 1));
            Set Player Variable(Event Player, ow2_scoped_damage_falloff_scalar, 1);
        "Min damage scalar"
        Else If(Compare((Event Player).ow2_scoped_damage_falloff_scalar, <, 0.5));
            Set Player Variable(Event Player, ow2_scoped_damage_falloff_scalar, 0.5);
        End;
        Set Player Variable(Event Player, scoped_damage_base, Divide(Event Damage, (Event Player).ow2_scoped_damage_falloff_scalar));
        Set Player Variable(Event Player, ow1_scoped_damage_falloff_scalar, Add(Multiply(Divide(Subtract((Event Player).scoped_shot_distance, 70), 30), 0.3), Subtract(1, Divide(Subtract((Event Player).scoped_shot_distance, 70), 30))));
        "Cap min/max scalar\r\n Max damage scalar"
        If(Compare((Event Player).ow1_scoped_damage_falloff_scalar, >, 1));
            Set Player Variable(Event Player, ow1_scoped_damage_falloff_scalar, 1);
        "Min damage scalar"
        Else If(Compare((Event Player).ow1_scoped_damage_falloff_scalar, <, 0.3));
            Set Player Variable(Event Player, ow1_scoped_damage_falloff_scalar, 0.3);
        End;
        Set Player Variable(Event Player, expected_scoped_damage, Multiply((Event Player).scoped_damage_base, (Event Player).ow1_scoped_damage_falloff_scalar));
        Damage(Victim, Attacker, Subtract((Event Player).expected_scoped_damage, Event Damage));
    }
}

rule ("[winston.opy]: Initialize Winston") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initWinston);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[winston.opy]: initWinston()") {
    event {
        Subroutine;
        initWinston;
    }
    actions {
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, health_normal, 350);
        Set Player Variable(Event Player, health_armor, 150);
        Set Player Variable(Event Player, health_shields, 0);
        Call Subroutine(applyCustomHealth);
        Wait(1, Ignore Condition);
        Loop If(Compare(Max Health(Event Player), !=, 500));
        Set Secondary Fire Enabled(Event Player, False);
    }
}

rule ("[winston.opy]: Set default leap cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Ability 1), 6);
    }
}

rule ("[winston.opy]: Set leap after ultimate") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ultimate(Event Player)), 9999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
    }
}

rule ("[wreckingball.opy]: Initialize Wrecking Ball") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initWreckingball);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[wreckingball.opy]: initWreckingball()") {
    event {
        Subroutine;
        initWreckingball;
    }
    actions {
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, health_normal, 500);
        Set Player Variable(Event Player, health_armor, 100);
        Set Player Variable(Event Player, health_shields, 0);
        Call Subroutine(applyCustomHealth);
        Wait(1, Ignore Condition);
        Loop If(Compare(Max Health(Event Player), !=, 600));
    }
}

rule ("[zarya.opy]: Initialize Zarya") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initZarya);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[zarya.opy]: initZarya()") {
    event {
        Subroutine;
        initZarya;
    }
    actions {
        Call Subroutine(clearCustomHealth);
        Set Player Variable(Event Player, health_normal, 200);
        Set Player Variable(Event Player, health_armor, 0);
        Set Player Variable(Event Player, health_shields, 200);
        Call Subroutine(applyCustomHealth);
        Wait(1, Ignore Condition);
        Loop If(Compare(Max Health(Event Player), !=, 400));
        Set Player Variable(Event Player, self_bubble_cooldown, 0);
        Set Player Variable(Event Player, ally_bubble_cooldown, 0);
    }
}

rule ("[zarya.opy]: showSelfBubbleCD()") {
    event {
        Subroutine;
        showSelfBubbleCD;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).self_bubble_cooldown, Up), Null, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(1.99, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.64, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, self_bubble_cd_text, Last Text ID);
        Modify Player Variable(Event Player, text_huds, Append To Array, (Event Player).self_bubble_cd_text);
    }
}

rule ("[zarya.opy]: hideSelfBubbleCD()") {
    event {
        Subroutine;
        hideSelfBubbleCD;
    }
    actions {
        Destroy In-World Text((Event Player).self_bubble_cd_text);
        Modify Player Variable(Event Player, text_huds, Remove From Array By Value, (Event Player).self_bubble_cd_text);
    }
}

rule ("[zarya.opy]: showAllyBubbleCD()") {
    event {
        Subroutine;
        showAllyBubbleCD;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).ally_bubble_cooldown, Up), Null, Null), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(2.3, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.66, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, ally_bubble_cd_text, Last Text ID);
        Modify Player Variable(Event Player, text_huds, Append To Array, (Event Player).ally_bubble_cd_text);
    }
}

rule ("[zarya.opy]: hideAllyBubbleCD()") {
    event {
        Subroutine;
        hideAllyBubbleCD;
    }
    actions {
        Destroy In-World Text((Event Player).ally_bubble_cd_text);
        Modify Player Variable(Event Player, text_huds, Remove From Array By Value, (Event Player).ally_bubble_cd_text);
    }
}

rule ("[zarya.opy]: OW1 zarya self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Ability Charge(Event Player, Button(Ability 1), 2);
        Set Ability 1 Enabled(Event Player, False);
        "2 second bubble duration"
        Wait(2, Ignore Condition);
        Set Player Variable(Event Player, self_bubble_cooldown, 10);
        Chase Player Variable At Rate(Event Player, self_bubble_cooldown, 0, 1, None);
    }
}

rule ("[zarya.opy]: OW1 zarya ally bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Ability Charge(Event Player, Button(Ability 2), 2);
        Set Ability 2 Enabled(Event Player, False);
        "2 second bubble duration"
        Wait(2, Ignore Condition);
        Set Player Variable(Event Player, ally_bubble_cooldown, 8);
        Chase Player Variable At Rate(Event Player, ally_bubble_cooldown, 0, 1, None);
    }
}

rule ("[zarya.opy]: Disable self bubble if on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).self_bubble_cooldown > 0;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
    }
}

rule ("[zarya.opy]: Disable ally bubble if on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).ally_bubble_cooldown > 0;
    }
    actions {
        Set Ability 2 Enabled(Event Player, False);
    }
}

rule ("[zarya.opy]: Enable self bubble if not on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).self_bubble_cooldown <= 0;
    }
    actions {
        Set Ability 1 Enabled(Event Player, True);
    }
}

rule ("[zarya.opy]: Enable ally bubble if not on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).ally_bubble_cooldown <= 0;
    }
    actions {
        Set Ability 2 Enabled(Event Player, True);
    }
}

rule ("[zarya.opy]: Draw self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).self_bubble_cooldown > 0;
    }
    actions {
        Call Subroutine(showSelfBubbleCD);
    }
}

rule ("[zarya.opy]: Erase self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).self_bubble_cooldown <= 0;
    }
    actions {
        Call Subroutine(hideSelfBubbleCD);
    }
}

rule ("[zarya.opy]: Draw self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).ally_bubble_cooldown > 0;
    }
    actions {
        Call Subroutine(showAllyBubbleCD);
    }
}

rule ("[zarya.opy]: Erase self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).ally_bubble_cooldown <= 0;
    }
    actions {
        Call Subroutine(hideAllyBubbleCD);
    }
}

rule ("[zenyatta.opy]: Initialize Zenyatta") {
    event {
        Ongoing - Each Player;
        All;
        Zenyatta;
    }
    conditions {
        "without this flag, the reset code in generic.opy executes after initialization"
        (Event Player).initialized == False;
    }
    actions {
        Call Subroutine(initZenyatta);
        Set Player Variable(Event Player, initialized, True);
    }
}

rule ("[zenyatta.opy]: initZenyatta()") {
    event {
        Subroutine;
        initZenyatta;
    }
    actions {
        Set Ammo(Event Player, 0, 20);
        Set Max Ammo(Event Player, 0, 20);
        Set Knockback Dealt(Event Player, 5);
        Call Subroutine(removeSelfHealing);
    }
}

rule ("[zenyatta.opy]: Allow self healing during Transcendence") {
    event {
        Ongoing - Each Player;
        All;
        Zenyatta;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, self_healing_percent, 100);
        Wait Until(Not(Is Using Ultimate(Event Player)), 9999);
        Set Player Variable(Event Player, self_healing_percent, 0);
    }
}

rule ("[debug.opy]: global debug (Top Left)") {
    event {
        Ongoing - Global;
    }
    conditions {
        Global.debug == True;
    }
    actions {
        Create HUD Text(All Players(All Teams), Custom String("Global", Null, Null, Null), Null, Null, Left, 0, Color(White), Null, Null, Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Custom String("Server Load: {0}%", Server Load, Null, Null), Null, Left, 1, Null, Color(White), Null, Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Custom String("Server Load Average: {0}%", Server Load Average, Null, Null), Null, Left, 1, Null, Color(White), Null, Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Custom String("Server Load Peak: {0}%", Server Load Peak, Null, Null), Null, Left, 1, Null, Color(White), Null, Visible To and String, Default Visibility);
    }
}

rule ("[debug.opy]: player debug (Top Right)") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.debug == True;
    }
    actions {
        Create HUD Text(Event Player, Custom String("Event Player", Null, Null, Null), Null, Null, Right, 0, Color(White), Null, Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getAltitude() = {0}", Altitude Of(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("hasStatusEffect(Status.HACKED) = {0}", Has Status(Event Player, Hacked), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getStatistic(Stat.HERO_DAMAGE_DEALT) = {0}", Player Stat(Event Player, Hero Damage Dealt), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("len(allowed_heroes) = {0}", Count Of((Event Player).allowed_heroes), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("len(getAllowedHeroes()) = {0}", Count Of(Allowed Heroes(Event Player)), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isUsingUltimate() = {0}", Is Using Ultimate(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getUltCharge() = {0}", Ultimate Charge Percent(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getUltCharge() >= 100 = {0}", Compare(Ultimate Charge Percent(Event Player), >=, 100), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isFiringPrimaryFire() = {0}", Is Firing Primary(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isFiringSecondaryFire() = {0}", Is Firing Secondary(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isUsingAbility1() = {0}", Is Using Ability 1(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("isUsingAbility2() = {0}", Is Using Ability 2(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("getSpeed() = {0}", Speed Of(Event Player), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("ult_cost[hero_id] = {0}", Value In Array(Global.ult_cost, (Event Player).hero_id), Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
        Create HUD Text(Event Player, Null, Custom String("ult_percent_compensated = {0}", (Event Player).ult_percent_compensated, Null, Null), Null, Right, 1, Null, Color(White), Null, String, Default Visibility);
    }
}

rule ("[debug.opy]: print to console on interact") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.debug == True;
        Is Button Held(Event Player, Button(Interact)) == True;
    }
    actions {
        For Global Variable(i, 0, Count Of((Event Player).allowed_heroes), 1);
            Log To Inspector(Custom String("eventPlayer.allowed_heroes[{0}] = {1}", Global.i, Value In Array((Event Player).allowed_heroes, Global.i), Null));
        End;
    }
}

rule ("[debug.opy]: Debug damage instance") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Global.debug == True;
    }
    actions {
        Log To Inspector(Custom String("{0} {1} {2}", Hero Of(Event Player), Event Ability, Event Damage));
    }
}

